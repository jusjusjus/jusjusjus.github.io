/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./web/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./code/annotation_list.js":
/*!*********************************!*\
  !*** ./code/annotation_list.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* global  HTMLElement,window */\n\n\n\nconst Papa = __webpack_require__(/*! papaparse */ \"./node_modules/papaparse/papaparse.min.js\");\nconst events = __webpack_require__(/*! ./custom_events */ \"./code/custom_events.js\");\nconst { unlabelled, sleepStages } = __webpack_require__(/*! ./config */ \"./code/config.js\");\nconst { argmax } = __webpack_require__(/*! ./utils */ \"./code/utils.js\");\n\nclass Annotation {\n\n  constructor(datetime, dt_s, label=null, sleepStageProbs=null) {\n    if (sleepStages.indexOf(label) > -1) {\n      this.label = label;\n    } else if (sleepStageProbs) {\n      this.sleepStageProbs = sleepStageProbs;\n    } else {\n      this.label = unlabelled;\n    }\n    this.datetime = datetime;\n    this.dt_s = dt_s;\n  }\n\n  update (label=null, probs=null) {\n    if (label) {\n      this.label = label;\n    }\n    if (probs) {\n      this.sleepStageProbs = probs;\n    }\n  }\n\n  get label () {\n    return this._label;\n  }\n\n  set label (l) {\n    this._label = l;\n    this._sleepStageProbs = [0, 0, 0];\n    if (sleepStages.indexOf(l) > -1) {\n      this._sleepStageProbs[sleepStages.indexOf(l)] = 1;\n    }\n  }\n\n  get sleepStageProbs () {\n    return this._sleepStageProbs;\n  }\n\n  set sleepStageProbs (p) {\n    this._sleepStageProbs = p;\n    this._label = sleepStages[argmax(p)];\n  }\n\n  get end_ms () {\n    return this.datetime.ms + 1000 * this.dt_s;\n  }\n\n}\n\nclass AnnotationsList {\n\n  constructor() {\n    this.annotations = [];\n  }\n\n  empty() {\n    // should probably warn that things are about to disappear\n    this.annotations = [];\n  }\n\n  /**\n   * Return iterator across annotations\n   */\n  [Symbol.iterator]() {\n    return this.annotations.values();\n  }\n\n  get length() {\n    return this.annotations.length;\n  }\n\n  remove(i) {\n    return this.annotations.splice(i, 1);\n  }\n\n  /**\n   * add new annotation while preserving order\n   *\n   * @param(datetime): datetime obj indicating event start\n   * @param(dt_s): event duration in seconds\n   * @param(label): event label string\n   */\n  add (datetime, dt_s, label, probs) {\n    const annot = new Annotation(datetime, dt_s, label, probs);\n    this.annotations.push(annot);\n  }\n\n  update (index, label=null, probs=null) {\n    this.annotations[Number(index)].update(label, probs);\n  }\n\n  annotsInWindow (windowStart_ms, windowLen_ms) {\n    let annots = [],\n        windowEnd_ms = windowStart_ms + windowLen_ms;\n    let index = 0;\n    for(let annot of this.annotations) {\n      // Check if event is completely outside window\n      if(windowEnd_ms - 100 < annot.datetime.ms  || annot.end_ms < windowStart_ms + 100) {\n        index++;\n        continue;\n      }\n      // {start,end} of annotation inside window\n      let start_ms = annot.datetime.ms > windowStart_ms ? annot.datetime.ms : windowStart_ms;\n      let end_ms = annot.end_ms < windowEnd_ms ? annot.end_ms : windowEnd_ms;\n      // convert from milliseconds to seconds\n      annots.push({\n        trel: 0.001 * (start_ms - windowStart_ms),\n        dt: 0.001 * (end_ms - start_ms),\n        label: annot.label,\n        index: index\n      });\n      index++;\n    }\n    return annots;\n  }\n\n  csv () {\n    const annots = [],\n          stages = [];\n    for (let stage of sleepStages) {\n      stages.push(stage.replace(' ', '_'));\n    }\n    this.annotations.forEach( annot => {\n      const a = {\n        start: annot.datetime.datetimestr,\n        duration: annot.dt_s,\n        label: annot.label\n      };\n      const p = annot.sleepStageProbs;\n      for (let s in stages) {\n        const stage = stages[s];\n        a[stage] = p[s];\n      }\n      annots.push(a);\n    });\n    return Papa.unparse(annots);\n  }\n}\n\nmodule.exports = {\n  Annotation: Annotation,\n  annotations: new AnnotationsList()\n};\n\n\n//# sourceURL=webpack:///./code/annotation_list.js?");

/***/ }),

/***/ "./code/annotation_list_elem.js":
/*!**************************************!*\
  !*** ./code/annotation_list_elem.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* global  HTMLElement,window */\n\n\n\nconst events = __webpack_require__(/*! custom_events */ \"./code/custom_events.js\");\nconst { annotations } = __webpack_require__(/*! annotation_list */ \"./code/annotation_list.js\");\nconst { UniversalDate } = __webpack_require__(/*! utils */ \"./code/utils.js\");\nconst ScoringConfig = __webpack_require__(/*! scoring_config */ \"./code/scoring_config.js\");\nconst config = __webpack_require__(/*! config */ \"./code/config.js\");\nconst ClassifyDialog = __webpack_require__(/*! classify_dialog */ \"./code/classify_dialog.js\");\nconst bioimagesuiteweb = window.bioimagesuiteweb;\nconst webutil = bioimagesuiteweb.webutil;\nconst webfileutil = bioimagesuiteweb.webfileutil;\n\n/** Create and activate an html element to trigger a download\n *\n * From:\n * https://stackoverflow.com/questions/21012580/is-it-possible-to-write-data-to-file-using-only-javascript\n */\nfunction download (fileContent, filename, strMimeType) {\n  const elem = document.createElement(\"a\");\n  elem.href = \"data:charset=utf-8,\" + escape(fileContent);\n\n  if (window.MSBlobBuilder) {\n    const bb = new MSBlobBuilder();\n    bb.append(fileContent);\n    return navigator.msSaveBlob(bb, filename);\n  }\n\n  if ('download' in elem) {\n    elem.setAttribute(\"download\", filename);\n    elem.innerHTML = \"downloading...\";\n    document.body.appendChild(elem);\n    setTimeout(() => {\n      const event = document.createEvent(\"MouseEvent\");\n      event.initMouseEvent(\"click\", true, false, window, 0, 0, 0,\n                           0, 0, false, false, false, false, 0, null);\n      elem.dispatchEvent(event);\n      document.body.removeChild(elem);\n    }, 66);\n  } else {\n    const f = document.createElement(\"iframe\");\n    document.body.appendChild(f);\n    f.src = \"data:application/octet-stream\" + (window.btoa ? \";base64\" : \"\");\n    f.src += \",\" + (window.btoa ? window.btoa : escape)(fileContent);\n    setTimeout(() => document.body.removeChild(f), 333);\n  }\n}\n\n\nconst HTML_ID = 'annotation-list';\n\nclass AnnotationListElement extends HTMLElement {\n\n  get html () {\n    return `\n    <div class='${HTML_ID}'>\n      <div  class=\"annot-list\">\n        <table id='${HTML_ID}'></table>\n      </div>\n      <div class=\"annot-control\">\n        <input class=\"annot-control\" type=\"button\" id=\"hideButton\" value=\"Hide\"></input>\n        <input class=\"annot-control\" type=\"button\" id=\"deleteButton\" value=\"Delete\"></input>\n      </div>\n    </div>`;\n  }\n\n  constructor () {\n    super();\n    this.annotations = annotations;\n    this.selectedIndex = 0;\n\n    const stageUpdateFactory = (key, stage) => {\n      return () => this.updateAnnotation(this.selectedIndex, stage);\n    };\n    this.scoringConfig = new ScoringConfig(stageUpdateFactory);\n  }\n\n  connectedCallback () {\n    this.addMenu();\n    this.connectWithSignalSource();\n    this.scoringConfig.connectedCallback();\n\n    this.elem = $(this.html);\n    this.appendChild(this.elem[0]);\n    this.table = this.elem.find(`[id='${HTML_ID}']`);\n    this.table.on('click', e => {\n      e.stopPropagation();\n      this.selectRow(e.target.parentNode);\n    });\n    // connect the button to hide the annotation list\n    this.elem.find(`[id=hideButton]`)[0].onclick = () => this.hide();\n    // Connect the button to remove the selected annotation\n    this.elem.find(`[id=deleteButton]`)[0].onclick = () => this.delete();\n    // Set up table scrolling\n    this.startRowIndex = 0;\n    this.rowsDisplayed = config.annotationRowsDisplayed;\n    this.tableScroller = this.elem.find('div.annot-list')[0];\n    this.tableScroller.addEventListener('scroll', e => {\n      const elem = e.target;\n      const factor = elem.scrollHeight - elem.clientHeight;\n      const fraction = elem.scrollTop / factor;\n      if (fraction > 1) {\n        this.loadNextPage(factor);\n      } else if (fraction < 0.01) {\n        this.loadPrevPage(factor);\n      }\n    });\n    this.refresh();\n  }\n\n  loadNextPage (factor) {\n    if (this.startRowIndex + this.rowsDisplayed == this.annotations.length) {\n      return;\n    }\n    this.startRowIndex += Math.round(0.9 * this.rowsDisplayed);\n    if (this.startRowIndex + this.rowsDisplayed > this.annotations.length) {\n      this.startRowIndex = this.annotations.length - this.rowsDisplayed;\n    }\n    this.tableScroller.scrollTop = Math.round(factor * 0.1);\n    this.refresh();\n  }\n\n  loadPrevPage (factor) {\n    if (this.startRowIndex === 0) {\n      return;\n    }\n    this.startRowIndex -= Math.round(0.9 * this.rowsDisplayed);\n    if (this.startRowIndex < 0) {\n      this.startRowIndex = 0;\n    }\n    this.tableScroller.scrollTop = Math.round(factor * 0.9);\n    this.refresh();\n  }\n\n  updateAnnotation (index, label, probs=null) {\n    this.annotations.update(index, label, probs);\n    let nextIndex = index + 1;\n    if (nextIndex === this.annotations.length) {\n      nextIndex = this.annotations.length - 1;\n    }\n    this.focusOnAnnotation(nextIndex);\n  }\n\n  async streamAnnotations ({classes, probs}) {\n    let index = null;\n    for (index in probs) {\n      const stageProbs = probs[index].slice(0, 3);\n      index = Number(index);\n      this.annotations.update(index, null, stageProbs);\n    }\n    this.focusOnAnnotation(index);\n  }\n\n  focusOnAnnotation (index, refresh=true) {\n    this.selectedIndex = index;\n    const annot = this.annotations.annotations[index];\n    this.signalSource.focusOnAnnotation(annot);\n    if (refresh) {\n      this.refresh();\n    }\n  }\n\n  hide() {\n    this.elem[0].style.width = '0';\n    document.getElementById('main').style.marginLeft = '0';\n    this.dispatchTimeChanged(null, null, 500);\n  }\n\n  /**\n   */\n  delete (index) {\n    if(index === undefined) {\n      index = this.selectedIndex;\n      this.selectedIndex = this.selectedIndex < 1 ? 0: (this.selectedIndex - 1);\n    }\n    this.annotations.update(index, 'UNK');\n    this.refresh();\n  }\n\n  dispatchTimeChanged (t0=null, dt=null, timeout=0) {\n    const event = new CustomEvent(events.TIME_CHANGED, {detail: {\n      t0: t0, dt: dt, source: this}});\n    if (timeout) {\n      setTimeout( () => window.dispatchEvent(event), timeout);\n    } else {\n      window.dispatchEvent(event);\n    }\n  }\n\n  refresh () {\n    this.updateHypnogram();\n    this.dispatchTimeChanged();\n    const columns = ['datetime', 'label'];\n    const valueFormatter = {\n      datetime: x => x.timestr,\n      dt_s: x => x.toFixed(3),\n      label: x => x\n    };\n    const formatName = {\n      datetime: 'Start',\n      dt_s: 'Duration (sec.)',\n      label: 'Label'\n    };\n    $(`#${HTML_ID} tr`).remove();\n    const headerRow = $('<tr>').addClass('annot-list');\n    for(let key of columns) {\n      const item = $('<th>').addClass('annot-list').text(formatName[key]);\n      headerRow.append(item);\n    }\n    this.table.append(headerRow);\n\n    const endRowIndex = Math.min(this.annotations.length, this.startRowIndex + this.rowsDisplayed);\n    for(let i = this.startRowIndex; i < endRowIndex; i++) {\n      const annot = this.annotations.annotations[i];\n      const row = $('<tr>').addClass(i === this.selectedIndex ? 'annot-list-selected': 'annot-list');\n      row.on('click', () => this.focusOnAnnotation(i, false) );\n      for(let key of columns) {\n        const format = valueFormatter[key];\n        const item = $('<td>').addClass('annot-list').text(format(annot[key]));\n        row.append(item);\n      }\n      this.table.append(row);\n    }\n  }\n\n  selectRow (row) {\n    const rows = this.table.find('tr.annot-list-selected');\n    for (let selected of rows) {\n      selected.classList.add('annot-list');\n      selected.classList.remove('annot-list-selected');\n    }\n    row.classList.add('annot-list-selected');\n    row.classList.remove('annot-list');\n  }\n\n  async updateHypnogram () {\n    const labels = [];\n    for (let annotation of this.annotations) {\n      labels.push(annotation.label);\n    }\n    window.dispatchEvent(new CustomEvent(events.HYPNOGRAM_UPDATE, {detail: {\n      label: labels\n    }}));\n  }\n\n  get hypnogram () {\n    // return html element given as attribute `signal-source`\n    return document.querySelector(this.getAttribute('hypnogram'));\n  }\n\n  get signalSource () {\n    // return html element given as attribute `signal-source`\n    return document.querySelector(this.getAttribute('signal-source'));\n  }\n\n  connectWithSignalSource() {\n    const source = this.signalSource;\n    if (source === null) {\n      return;\n    }\n    source.addEventListener(events.CLOSE_FILE, () => {\n      this.dropdown.classList.add('disabled');\n      this.annotations.empty();\n      this.selectedIndex = 0;\n      this.refresh();\n    });\n    source.addEventListener(events.OPEN_FILE,\n      ({detail}) => {\n        // detail = {\n        //   startdatetime: this.source.startdatetime,\n        //   filename: this.source.filename,\n        //   duration: this.source.duration\n        // }\n        this.sourcefilename = detail.filename;\n        this.dropdown.classList.remove('disabled');\n        const start_ms = detail.startdatetime.ms;\n        const numAnnots = Math.floor(detail.duration / config.epochDuration);\n        for (let i = 0; i < numAnnots; i++) {\n          const epochstart_ms = start_ms + 1000 * i * config.epochDuration;\n          const start = new UniversalDate(new Date(epochstart_ms));\n          this.annotations.add(start, config.epochDuration);\n        }\n      });\n  }\n\n  get menubar() {\n    // return html element given as attribute `menubar`\n    const mb = document.querySelector(this.getAttribute('menubar'));\n    return mb ? mb.menubar : null;\n  }\n\n  addMenu () {\n    if(this.menubar === null) {\n      return;\n    }\n    const menu = webutil.createTopMenuBarMenu(\"Annotations\", this.menubar);\n    this.dropdown = menu.parent()[0].childNodes[0];\n    this.dropdown.classList.add('disabled');\n    // create menu item to open local files\n    webutil.createMenuItem(menu, 'Open', async () => this.openReview() );\n    webutil.createMenuItem(menu, 'Close', async () => this.hide() );\n    webutil.createMenuItem(menu, '');\n    webutil.createMenuItem(menu, 'Download', async () => this.downloadAnnotations());\n    webutil.createMenuItem(menu, 'Delete all', async () => this.clearAll());\n  }\n\n  clearAll() {\n    for (let annot of this.annotations) {\n      annot.label = 'UNK';\n    }\n    this.refresh();\n  }\n\n  addAnnotation (datetime, duration, label) {\n    this.annotations.add(datetime, duration, label);\n  }\n\n  dispatchUpdate (time, dt_s) {\n    const annots = this.annotations.annotsInWindow(time.ms, 1000 * dt_s);\n    for (let annot of annots) {\n      annot.selected = annot.index === this.selectedIndex;\n    }\n    this.dispatchEvent(new CustomEvent(events.ANNOTS_UPDATE, {detail: annots, bubbles: false}));\n  }\n\n  openReview() {\n    this.refresh();\n    let width = '150px';\n    this.elem[0].style.width = width;\n    document.getElementById('main').style.marginLeft = width;\n    this.dispatchTimeChanged(null, null, 500);\n  }\n\n  downloadAnnotations() {\n    const csv = this.annotations.csv();\n    const filename = this.sourcefilename.split('.')[0];\n    download(csv, `annotations-${filename}.csv`);\n  }\n\n}\n\nwindow.customElements.define(HTML_ID, AnnotationListElement);\n\n\n//# sourceURL=webpack:///./code/annotation_list_elem.js?");

/***/ }),

/***/ "./code/classifier.js":
/*!****************************!*\
  !*** ./code/classifier.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* global window */\n\n\n\nconst path = __webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\");\n\nfunction assert(condition, msg) {\n  if (!condition) {\n    console.error(msg);\n    throw msg;\n  }\n}\n\nfunction readPlainText(filename) {\n  return new Promise(resolve => {\n    if (!XMLHttpRequest) {\n      const buffer = fs.readFileSync(filename);\n      resolve(buffer);\n    } else {\n      const rawFile = new XMLHttpRequest();\n      rawFile.overrideMimeType(\"application/json\");\n      rawFile.open(\"GET\", filename, true);\n      rawFile.onreadystatechange = () => {\n        if (rawFile.readyState === 4 && rawFile.status == \"200\") {\n          resolve(rawFile.responseText);\n        }\n      };\n      rawFile.send(null);\n    }\n  });\n}\n\nclass Classifier {\n\n  constructor() {\n    this.config = null;\n    this.net = null;\n  }\n\n  loadConfig(filename) {\n    return new Promise(resolve => {\n      readPlainText(filename).then( (txt) => {\n        const obj = JSON.parse(txt);\n        resolve(obj);\n      });\n    });\n  }\n\n  async loadModel(modelpath='./web/models/EEG2') {\n    assert(this.net === null, \"Warning re-loading net\");\n    const modelfile = path.join(modelpath, 'model.json'),\n          configfile = path.join(modelpath, 'config.json');\n    this.config = await this.loadConfig(configfile);\n    this.net = await tf.loadModel(modelfile);\n  }\n\n  input_sampling_rate() {\n    return this.config.input.sampling_rate;\n  }\n\n  predict(input) {\n    if (this.net === null) {\n      this.loadModel();\n    }\n    assert(input.shape.length == 3 && input.shape[1] && input.shape[2],\n           `input with wrong shape: ${input.shape}`);\n    const mixed_logp = this.net.predictOnBatch(input);\n    const log_stage = mixed_logp.slice([0, 0], [-1, 3]);\n    const log_artif = mixed_logp.slice([0, 3], [-1, 1]);\n    return tf.concat([\n      tf.softmax(log_stage),\n      tf.exp(log_artif)\n    ], 1);\n  }\n\n}\n\nmodule.exports = Classifier;\n\n\n//# sourceURL=webpack:///./code/classifier.js?");

/***/ }),

/***/ "./code/classify_dialog.js":
/*!*********************************!*\
  !*** ./code/classify_dialog.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* global  HTMLElement,window */\n\n\nconst $ = window.jQuery;\nconst webutil = window.bioimagesuiteweb.webutil;\nconst Dataset = __webpack_require__(/*! dataset */ \"./code/dataset.js\");\nconst Dataloader = __webpack_require__(/*! dataloader */ \"./code/dataloader.js\");\nconst Classifier = __webpack_require__(/*! classifier */ \"./code/classifier.js\");\nconst { concatenate } = __webpack_require__(/*! utils */ \"./code/utils.js\");\nconst { SelectionDialog } = __webpack_require__(/*! dialogs */ \"./code/dialogs.js\");\nconst config = __webpack_require__(/*! config */ \"./code/config.js\");\n\n/** class ClassifyDialog\n *\n * Display information about this program\n */\nclass ClassifyDialog {\n\n  get title() {\n    return \"Classify sleep stages\";\n  }\n\n  get html() {\n    return `\n      <div class=\"selection-dialog\" id=\"classify-div\">\n      <ul id=\"model-selection-list\"></ul>\n      <p>Select channels as input:</p>\n      <ul id=\"channel-selection-list\"></ul>\n      </div>`;\n  }\n\n  constructor(signalSource, annotationListElement) {\n    this.signalSource = signalSource;\n    this.annotationListElement = annotationListElement;\n    this.clf = null;\n    this.inputChannelMap = {};\n    this.dialog = webutil.createmodal(this.title, \"modal-sm classify-dialog\");\n    // impute class \"close-button\" to the button element\n    const closeButton = this.dialog.footer[0].childNodes[1];\n    closeButton.classList.add(\"close-button\");\n    this.elem = $(this.html);\n    this.dialog.body.append(this.elem);\n    this.setupModelList();\n  }\n\n  async predict () {\n    const dloader = new Dataloader(this.dataset, config.batchSize);\n    let startIndex = 0;\n    for (let batchByLabel of dloader) {\n      let batch = [];\n\n      // flatten input data\n      batchByLabel = await batchByLabel;\n      const batchSize = batchByLabel[this.dataset.channels[0]].length;\n      const inputShape = [this.dataset.channels.length, batchSize, this.clf.config.input.length];\n      for (let label of this.dataset.channels) {\n        const signals = batchByLabel[label];\n        batch.push(concatenate(Float32Array, signals));\n      }\n      batch = concatenate(Float32Array, batch);\n\n      // apply classifier\n      const rawProbs = tf.tidy( () =>\n        {\n          const reshaped = tf.tensor3d(batch, inputShape);\n          const transposed = tf.transpose(reshaped, [1, 2, 0]);\n          const predictions = this.clf.predict(transposed);\n          return predictions;\n        }\n      ).buffer().values;\n      this.streamAnnotations(rawProbs, startIndex, batchSize);\n      startIndex += batchSize;\n      await this.sleep();\n    }\n  }\n\n  sleep () {\n    return new Promise(resolve => setTimeout(resolve, 0));\n  }\n\n  async predictSelected() {\n    const index = this.annotationListElement.selectedIndex;\n    const signalByLabel = await this.dataset.get(index);\n    let signals = [];\n    for (let label of this.dataset.channels) {\n      signals.push(signalByLabel[label]);\n    }\n    signals = concatenate(Float32Array, signals);\n    const inputShape = [1, this.dataset.channels.length, this.clf.config.input.length];\n\n    // apply classifier\n    const rawProbs = tf.tidy( () =>\n      {\n        const reshaped = tf.tensor3d(signals, inputShape);\n        const transposed = tf.transpose(reshaped, [0, 2, 1]);\n        const predictions = this.clf.predict(transposed);\n        return predictions;\n      }\n    ).buffer().values;\n    this.streamAnnotations(rawProbs, index, 1);\n  }\n\n  streamAnnotations (rawProbs, startIndex, num) {\n    const probs = {};\n    const nc = this.clf.config.output.classes.length;\n    for (let i = 0; i < num; i++) {\n      probs[startIndex + i] = rawProbs.slice(nc * i, nc * (i + 1));\n    }\n    const update = {\n      classes: this.clf.config.output.classes,\n      probs: probs\n    };\n    this.annotationListElement.streamAnnotations(update);\n  }\n\n  setupModelList() {\n    const list = this.elem.find(`[id=model-selection-list]`);\n    const models = ['EEG2', 'EEG2-EMG', 'EEG1-EEG2-EMG'];\n    for (let model of models) {\n      const newItem = $('<li class=\"selection-dialog\">').text(model);\n      newItem.on('click', async (e) => {\n        for (let item of list[0].children) {\n          item.classList.remove(\"selected\");\n        }\n        e.target.classList.add(\"selected\");\n        this.selectModel(`models/${model}`);\n      });\n      list.append(newItem);\n    }\n  }\n\n  async selectModel(modelpath) {\n    this.clf = new Classifier();\n    await this.clf.loadModel(modelpath);\n    this.inputChannelMap = {};\n    for (let label of this.clf.config.input.channels) {\n      this.inputChannelMap[label] = null;\n    }\n    this.setupModelConfig();\n    this._selector = null;\n    this.dataset = new Dataset(\n      this.signalSource,\n      this.clf.config.input.duration,\n      this.clf.config.input.left,\n      this.clf.config.input.right\n    );\n    this.dataset.channels = this.clf.config.input.channels;\n  }\n\n  get selector() {\n    if (!this._selector) {\n      this._selector = new SelectionDialog(\"select-channel-slots-dialog\");\n    }\n    return this._selector;\n  }\n\n  setupModelConfig() {\n    const list = this.elem.find(`[id=channel-selection-list]`);\n    list.children().remove();\n    this.clf.config.input.channels.forEach( (inputLabel, inputIndex) => {\n      const newItem = $('<li class=\"selection-dialog\">').text(inputLabel);\n      newItem.on('click', async e => {\n        this.selector.title = `Select input for '${inputLabel}'`;\n        this.selector.choices = this.signalSource.labels;\n        this.selector.callback = selection => {\n          e.target.innerHTML = `${selection} => ${inputLabel}`;\n          this.setInputChannelMap(inputLabel, selection);\n        };\n        this.selector.show();\n      });\n      list.append(newItem);\n    });\n  }\n\n  setInputChannelMap(inputLabel, sourceLabel) {\n    this.inputChannelMap[inputLabel] = sourceLabel;\n    this.signalSource.cacheChannel(\n      sourceLabel, inputLabel, this.clf.config.input.sampling_rate);\n  }\n\n  checkModelConfigured () {\n    // Check if all input labels have been assigned a channel\n    if (!this.clf) {\n      return false;\n    }\n    for (let channel of this.clf.config.input.channels) {\n      if (this.inputChannelMap[channel] === null) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  show() {\n    this.dialog.dialog.modal('show');\n  }\n\n}\n\nmodule.exports = ClassifyDialog;\n\n\n//# sourceURL=webpack:///./code/classify_dialog.js?");

/***/ }),

/***/ "./code/classify_elem.js":
/*!*******************************!*\
  !*** ./code/classify_elem.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* global  HTMLElement,window */\n\n\n\nconst events = __webpack_require__(/*! custom_events */ \"./code/custom_events.js\");\nconst ClassifyDialog = __webpack_require__(/*! classify_dialog */ \"./code/classify_dialog.js\");\nconst bioimagesuiteweb = window.bioimagesuiteweb;\nconst webutil = bioimagesuiteweb.webutil;\nconst webfileutil = bioimagesuiteweb.webfileutil;\n\nconst HTML_ID = 'classify-element';\n\nclass ClassifyElement extends HTMLElement {\n\n  connectedCallback () {\n    this.addMenu();\n    this.connectWithSignalSource();\n  }\n\n  addMenu () {\n    if(this.menubar === null) {\n      return;\n    }\n    const menu = webutil.createTopMenuBarMenu(\"Automatic\", this.menubar);\n    this.dropdown = menu.parent()[0].childNodes[0];\n    this.dropdown.classList.add('disabled');\n    // create menu item to open local files\n    webutil.createMenuItem(menu, 'Predict selected', async () => this.predictSelected() );\n    webutil.createMenuItem(menu, 'Predict all', async () => this.predictAll() );\n    webutil.createMenuItem(menu, '');\n    webutil.createMenuItem(menu, 'Configure', async () => this.classifyDialog.show() );\n  }\n\n  predictSelected () {\n    if (this.classifyDialog.checkModelConfigured()) {\n      this.classifyDialog.predictSelected();\n    } else {\n      this.classifyDialog.show();\n    }\n  }\n\n  predictAll () {\n    if (this.classifyDialog.checkModelConfigured()) {\n      this.classifyDialog.predict();\n    } else {\n      this.classifyDialog.show();\n    }\n  }\n\n  connectWithSignalSource() {\n    const source = this.signalSource;\n    if (source === null) {\n      return;\n    }\n    const predictCallback = () => this.predictSelected();\n    \n    source.addEventListener(events.CLOSE_FILE, () => {\n      delete this.classifyDialog;\n      this.dropdown.classList.add('disabled');\n      window.dispatchEvent(new CustomEvent(events.UNREGISTER_KEY, {detail: {\n        key: 'P', callback: predictCallback}}));\n    });\n    source.addEventListener(events.OPEN_FILE,\n      ({detail}) => {\n        // detail = {\n        //   startdatetime: this.source.startdatetime,\n        //   filename: this.source.filename,\n        //   duration: this.source.duration\n        // }\n        this.sourcefilename = detail.filename;\n        this.dropdown.classList.remove('disabled');\n        window.dispatchEvent(new CustomEvent(events.REGISTER_KEY, {detail: {\n            key: 'P', callback: predictCallback }}));\n      });\n  }\n\n  get classifyDialog() {\n    if (!this._classifyDialog) {\n      this._classifyDialog = new ClassifyDialog(this.signalSource.source,\n                                                this.annotationList);\n    }\n    return this._classifyDialog;\n  }\n\n  get menubar() {\n    // return html element given as attribute `menubar`\n    const mb = document.querySelector(this.getAttribute('menubar'));\n    return mb ? mb.menubar : null;\n  }\n\n  get signalSource () {\n    // return html element given as attribute `signal-source`\n    return document.querySelector(this.getAttribute('signal-source'));\n  }\n\n  get annotationList () {\n    // return html element given as attribute `signal-source`\n    return document.querySelector(this.getAttribute('annotation-list'));\n  }\n\n}\n\nwindow.customElements.define(HTML_ID, ClassifyElement);\n\n\n//# sourceURL=webpack:///./code/classify_elem.js?");

/***/ }),

/***/ "./code/config.js":
/*!************************!*\
  !*** ./code/config.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n/** Configuration\n *\n * outputSamplingRate: sampling rate for all channels.  Channels with smaller\n * sampling rate will not be shown.\n *\n * physicalUnits: output physical units.  All units will be converted to\n * `physicalUnits` if possible.\n *\n * defaultLabels: list of channels that are activated when a new file is\n * loaded.\n *\n * windowDuration: duration of the displayed window in seconds.\n *\n * yrange: range of y-axis of each view.\n */\n\nconst EPOCHDURATION = 4;\nconst UNLABELLED = 'UNK';\nconst BATCHSIZE = 64;\n\nmodule.exports = {\n  outputSamplingRate: 64.0,\n  physicalUnits: 'uV',\n  defaultLabels: ['EEG1.1', 'EEG2.1', 'EMG.1'],\n  epochDuration: EPOCHDURATION,\n  unlabelled: UNLABELLED,\n  windowDuration: 8 + EPOCHDURATION + 8,\n  positiveIsUp: true,\n  yrange: [-140, 140],\n  sleepStages: ['Wake', 'REM', 'Non REM'],\n  batchSize: BATCHSIZE,\n  annotationRowsDisplayed: 128\n};\n\n\n//# sourceURL=webpack:///./code/config.js?");

/***/ }),

/***/ "./code/custom_colors.js":
/*!*******************************!*\
  !*** ./code/custom_colors.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nfunction rgba(r, g, b, a) {\n  return `rgba(${r}, ${g}, ${b}, ${a})`;\n}\n\nconst annotationFillColor = {\n  selected: {\n    UNK: rgba(0, 0, 0, 0.5),\n    Wake: rgba(0, 0, 255, 0.7),\n    'Non REM': rgba(0, 255, 0, 0.7),\n    REM: rgba(255, 0, 0, 0.7),\n  },\n  unselected: {\n    UNK: rgba(0, 0, 0, 0.4),\n    Wake: rgba(0, 0, 255, 0.4),\n    'Non REM': rgba(0, 255, 0, 0.4),\n    REM: rgba(255, 0, 0, 0.4),\n  }\n};\n\nconst annotationBoarderColor = {\n  UNK: '#666666',\n  Wake: '#999944',\n  'Non REM': '#444499',\n  REM: '#449944',\n};\n\n\nmodule.exports = {\n  annotations: {\n    fill: annotationFillColor,\n    line: annotationBoarderColor\n  }\n};\n\n\n//# sourceURL=webpack:///./code/custom_colors.js?");

/***/ }),

/***/ "./code/custom_events.js":
/*!*******************************!*\
  !*** ./code/custom_events.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nconst events = {\n  OPEN_FILE: 'open-file',\n  CLOSE_FILE: 'close-file',\n  REGISTER_KEY: 'register-key',\n  UNREGISTER_KEY: 'unregister-key',\n  TIME_CHANGED: 'time-changed',\n  SIGNAL_UPDATE: 'signal-update',\n  ANNOTS_UPDATE: 'annots-update',\n  HYPNOGRAM_UPDATE: 'hypnogram-update'\n};\n\nmodule.exports = events;\n\n\n//# sourceURL=webpack:///./code/custom_events.js?");

/***/ }),

/***/ "./code/dataloader.js":
/*!****************************!*\
  !*** ./code/dataloader.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n\n// class Dataloader {\n//\n//   constructor(dataset, batchSize=4) {\n//     this.dataset = dataset;\n//     this.batchSize = batchSize;\n//   }\n//\n//   async *[Symbol.iterator]() {\n//     let batch = [];\n//     for (let i = 0; i < this.dataset.length; i++) {\n//       console.log(i);\n//       batch.push(await this.dataset.get(i));\n//       if (batch.length === this.batchSize) {\n//         // console.log(batch);\n//         // yield batch;\n//         // batch = [];\n//       }\n//     }\n//     if (batch.length > 0) {\n//       yield batch;\n//     }\n//     yield true;\n//   }\n//\n// }\n\nclass Dataloader {\n  constructor (dataset, batchSize=4) {\n    this.dataset = dataset;\n    this.batchSize = batchSize;\n  }\n\n  get length () {\n    const numBatches = Math.floor(this.dataset.length / this.batchSize);\n    return numBatches + (this.dataset.length % this.batchSize > 0);\n  }\n\n  *[Symbol.iterator] () {\n    // build an set of index lists\n    const indexSet = [];\n    let indexList = [];\n    for (let i = 0; i < this.dataset.length; i++) {\n      indexList.push(i);\n      if (indexList.length === this.batchSize) {\n        indexSet.push(indexList);\n        indexList = [];\n      }\n    }\n    if (indexList.length > 0) {\n      indexSet.push(indexList);\n    }\n    // build a batch from each index list\n    for (indexList of indexSet) {\n      yield new Promise( async resolve => {\n        const batch = {};\n        for (let index of indexList) {\n          const samplesByLabel = await this.dataset.get(index);\n          for (let label in samplesByLabel) {\n            const samples = samplesByLabel[label];\n            if (!batch[label]) {\n              batch[label] = [];\n            }\n            batch[label].push(samples);\n          }\n        }\n        resolve(batch);\n      });\n    }\n  }\n}\n\nmodule.exports = Dataloader;\n\n\n//# sourceURL=webpack:///./code/dataloader.js?");

/***/ }),

/***/ "./code/dataset.js":
/*!*************************!*\
  !*** ./code/dataset.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* global window */\n\n\n\nclass Dataset {\n\n  constructor(source, epochDuration, left=0, right=0) {\n    this.source = source;\n    this.epochDuration = epochDuration;\n    this.left = left;\n    this.right = right;\n  }\n\n  get length() {\n    return Math.floor(this.source.duration / this.epochDuration);\n  }\n\n  get channels() {\n    return this._channels ? this._channels: null;\n  }\n\n  set channels(channels) {\n    this._channels = channels;\n  }\n\n  async get(index) {\n    let t0 = index * this.epochDuration - this.left;\n    const dt = this.left + this.epochDuration + this.right;\n    if (t0 < 0) {\n      t0 = 0;\n    } else if (t0 + dt > this.source.duration) {\n      t0 = this.source.duration - dt;\n    }\n    const channels = this.channels;\n    const samplesByLabel = await this.source.get_physical_samples(t0, dt, channels);\n    return samplesByLabel;\n  }\n}\n\nmodule.exports = Dataset;\n\n\n//# sourceURL=webpack:///./code/dataset.js?");

/***/ }),

/***/ "./code/dialogs.js":
/*!*************************!*\
  !*** ./code/dialogs.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* global  HTMLElement,window */\n\n\nconst $ = window.jQuery;\nconst webutil = window.bioimagesuiteweb.webutil;\nconst events = __webpack_require__(/*! custom_events */ \"./code/custom_events.js\");\nconst config = __webpack_require__(/*! config */ \"./code/config.js\");\n\nclass UrlDialog {\n  get html() {\n    return `\n    <div>\n      <input class=\"selection-dialog\" type=\"text\" />\n      <p class=\"attention\"></p>\n    </div>`;\n  }\n\n  constructor(callback) {\n    this.callback = callback;\n    this.dialog = webutil.createmodal(\"Enter URL\", \"modal-sm\");\n    this.closeButton = this.dialog.footer[0].childNodes[1];\n    this.closeButton.classList.add(\"close-button\");\n    const elem = $(this.html);\n    this.dialog.body.append(elem);\n    this.info = elem.find(\"p.attention\");\n    this.input = elem.find(\"input.selection-dialog\");\n    this.input.on('keydown', async (e) => {\n      if (e.key === 'Enter') {\n        try {\n          await this.callback(this.url);\n          this.closeButton.click();\n        } catch (e) {\n          this.info.text(`invalid url: '${e}'`);\n        }\n      }\n    });\n  }\n\n  set url (url) {\n    this.input[0].value = url;\n  }\n\n  get url () {\n    return this.input[0].value;\n  }\n\n  show() {\n    this.dialog.dialog.modal('show');\n    this.input.focus();\n  }\n\n}\n\n\nclass SelectionDialog {\n\n  get html() {\n    return `\n    <div>\n      <input class=\"selection-dialog\" type=\"text\" placeholder=\"Filter choices\" />\n      <ul class=\"selection-dialog\"></ul>\n    </div>`;\n  }\n\n  constructor(classname) {\n    let modalClass = \"modal-sm\";\n    if (classname) {\n      modalClass += ' ' + classname;\n    }\n    this.callback = null;\n    this.dialog = webutil.createmodal(\"Select\", modalClass);\n    const closeButton = this.dialog.footer[0].childNodes[1];\n    closeButton.classList.add(\"close-button\");\n    this.elem = $(this.html);\n    this.dialog.body.append(this.elem);\n    this.list = this.elem.find(\"ul.selection-dialog\");\n    this.filter = this.elem.find(\"input.selection-dialog\");\n    this.filter.on('keyup', async () => await this.filterChoices());\n  }\n\n  set title(t) {\n    const elem = this.dialog.titlediv[0];\n    elem.innerHTML = t;\n  }\n\n  set choices (items) {\n    this.list.children().remove();\n    for(let item of items) {\n      this.addChoice(item);\n    }\n\t}\n\n  addChoice (item) {\n    const li = $('<li class=\"selection-dialog\">').text(item);\n    li.on('click', (e) => {\n      for (let elem of this.list[0].childNodes ) {\n        elem.classList.remove(\"selected\");\n      }\n      e.target.classList.add(\"selected\");\n      this.callback(e.target.innerHTML);\n    });\n    this.list.append(li);\n  }\n\n  async filterChoices() {\n    const filter = this.filter[0].value;\n    for(let li of this.list.children()) {\n      li.style.display = li.textContent.indexOf(filter) > -1 ? \"\": \"none\";\n    }\n  }\n\n  show() {\n    this.dialog.dialog.modal('show');\n  }\n\n}\n\n/** class DerivationDialog\n *\n * Construct derivations to display\n */\nclass DerivationDialog extends SelectionDialog {\n\n  constructor(callback) {\n    super('derivation-dialog');\n    this.title = \"Select channels\";\n    this.toggleCallback = callback;\n  }\n\n  addChoice (label) {\n    const li = $('<li class=\"selection-dialog\">').text(label);\n    li.on('click', (e) => {\n      if(e.target.classList.contains(\"selected\")) {\n        e.target.classList.remove(\"selected\");\n      } else {\n        e.target.classList.add(\"selected\");\n      }\n      this.toggleCallback(e.target.innerHTML);\n    });\n    this.list.append(li);\n  }\n\n}\n\n/** class AboutDialog\n *\n * Display information about this program\n */\nclass AboutDialog {\n\n  get title() {\n    return \"About this Application\";\n  }\n\n  get html() {\n    return `<P>This application automatically annotates EEG signals with sleep stages.</P>`;\n  }\n\n  constructor() {\n    this.dialog = webutil.createmodal(this.title, \"modal-sm\");\n    this.content = $(this.html);\n    this.dialog.body.append(this.content);\n  }\n\n  show() {\n    this.dialog.dialog.modal('show');\n  }\n\n}\n\n\nmodule.exports = {\n  SelectionDialog: SelectionDialog,\n  DerivationDialog: DerivationDialog,\n  AboutDialog: AboutDialog,\n  UrlDialog: UrlDialog\n};\n\n\n//# sourceURL=webpack:///./code/dialogs.js?");

/***/ }),

/***/ "./code/filtered_edf.js":
/*!******************************!*\
  !*** ./code/filtered_edf.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nconst edfjs = __webpack_require__(/*! edfjs */ \"./node_modules/edfjs/src/index.js\");\n\nconst _filters = {};\n\nfunction get_filter (fs, fc) {\n  const hash = fs + '_to_' + fc;\n  if (_filters[hash] === undefined) {\n    const iirCalculator = new Fili.CalcCascades();\n    const availableFilters = iirCalculator.available();\n    const iirFilterCoeffs = iirCalculator.lowpass({\n      order: 4, characteristic: 'butterworth',\n      Fs: fs, Fc: fc, gain: 0, preGain: false\n    });\n    _filters[hash] = new Fili.IirFilter(iirFilterCoeffs);\n  }\n  return _filters[hash];\n};\n\nfunction linear_downsample (X, srOld, srNew) {\n  const F = get_filter(srOld, 0.4*srNew);\n  X = F.filtfilt(X);\n  const t = Float32Array.from(\n    new Array(Math.round((X.length - 1) * srNew / srOld)),\n              (val, idx) => idx * srOld / srNew);\n  const I = Int32Array.from(t);\n  const x = new Float32Array(t.length);\n  x[0] = X[0];\n  for (var i = 1; i < t.length; i++) {\n    var n = I[i], n1 = I[i]+1;\n    x[i] = X[n1] * (t[i] - n) + X[n] * (n1 - t[i]);\n  }\n  return x;\n};\n\nfunction assert(condition, msg) {\n  if (!condition) console.error(msg);\n}\n\nclass FilteredEDF extends edfjs.EDF {\n\n  cacheChannel (label, cacheLabel, srNew) {\n    if (cacheLabel in this.channel_by_label) {\n      delete this.channel_by_label[cacheLabel];\n    }\n    const channelToCache = this.channel_by_label[label];\n    const srOld = channelToCache.sampling_rate;\n    const cached = new edfjs.Channel();\n    cached.blob = Float32Array.from(\n      linear_downsample(channelToCache.blob, srOld, srNew));\n    cached.sampling_rate = srNew;\n    cached.label = label;\n    cached.channel_type = channelToCache.channel_type;\n    cached.physical_dimension = channelToCache.physical_dimension;\n    cached.prefiltering = channelToCache.prefiltering;\n    this.channel_by_label[cacheLabel] = cached;\n  }\n\n}\n\nmodule.exports = {\n  FilteredEDF: FilteredEDF,\n  get_filter: get_filter\n};\n\n\n//# sourceURL=webpack:///./code/filtered_edf.js?");

/***/ }),

/***/ "./code/hypnogram_elem.js":
/*!********************************!*\
  !*** ./code/hypnogram_elem.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nconst Plotly = window.Plotly;\nconst $ = window.jQuery;\nconst events = __webpack_require__(/*! custom_events */ \"./code/custom_events.js\");\nconst { epochDuration } = __webpack_require__(/*! config */ \"./code/config.js\");\n\n// Define and hash a class-to-location mapping that we use later to assign\n// to a particular class label a position on the y-axis\n\nconst classes = ['UNK', 'Wake', 'REM', 'Non REM'];\nconst hash2label = [];\nfor (let i = 1; i <= classes.length; i++) {\n  hash2label[i - 1] = classes[classes.length - i];\n}\nconst label2hash = {};\nfor (let l in hash2label) {\n  label2hash[hash2label[l]] = l;\n}\n\nfunction labels2curve(annotations) {\n  const labels = annotations.label;\n  const hoursPerSecond = 1 / 60 / 60,\n        dt = epochDuration * hoursPerSecond,\n        x = [0],\n        y = [label2hash[labels[0]]],\n        c = ['rgb(0,0,0)'];\n  let label = labels[0],\n      next_label = null;\n  for (let l = 0; l < labels.length; l++) {\n    const l1 = l + 1;\n    next_label = labels[l1];\n    if (next_label !== label) {\n      // add y again to get vertical lines\n      x.push(l1 * dt);\n      y.push(label2hash[label]);\n      c.push('rgb(0,0,0)');\n      label = next_label;\n    }\n    x.push(l1 * dt);\n    y.push(label2hash[next_label]);\n    c.push('rgb(0,0,0)');\n  }\n  return {x: [x], y: [y], 'marker.color': [c]};\n}\n\nconst HTML_ID = 'hypnogram-view';\nconst DRAWINGAREA_ID = 'drawingArea';\n\nclass HypnogramElement extends HTMLElement {\n\n  get html() {\n    return `<div class='${HTML_ID}' id='${DRAWINGAREA_ID}' style='height:150px;width:100%;'></div>`;\n  }\n\n  get layout() {\n    return {\n      dragmode: false,\n      hovermode: 'x',\n      showlegend: false,\n      xaxis: { title: \"relative time (hours)\" },\n      margin: { t: 0, b: 30, l: 40, r: 20 }\n    };\n  }\n\n  constructor() {\n    super();\n    this.config = { displayModeBar: false };\n  }\n\n  connectedCallback() {\n    const elem = $(this.html);\n    this.appendChild(elem[0]);\n    this.drawingArea = elem;\n    // listen for hypnogram data\n    window.addEventListener(events.HYPNOGRAM_UPDATE, ({detail}) => this.update(detail));\n    window.addEventListener(events.CLOSE_FILE, () => this.drawingArea.html('') );\n    window.addEventListener(events.TIME_CHANGED, ({detail}) => this.setVert(detail.t0 + detail.dt / 2));\n    // Clicking on the canvas displays the 30-second epoch\n  }\n\n  async update (annotations) {\n    const tickvals = [];\n    for(let tt in hash2label) {\n      tickvals[tt] = tt;\n    }\n    const curve = labels2curve(annotations);\n    const layout = this.layout;\n    layout.xaxis.range = [0, curve.x[curve.x.length - 1] + 0.1];\n    layout.yaxis = {};\n    layout.yaxis.tickvals = tickvals;\n    layout.yaxis.ticktext = hash2label;\n\n    const trace = {\n      type: 'scatter',\n      x: curve.x[0], y: curve.y[0],\n      mode: \"lines\",\n      line: {\n        color: 'grey',\n        width: 2\n      },\n      yaxis: \"y\"\n    };\n    const vert = {\n      x: [0, 0], y: [-0.5, hash2label.length - 0.5],\n      mode: \"lines\",\n      line: { color: 'rgb(0.25,0.25,0.25)', width: 2.0 },\n    };\n    await Plotly.newPlot(this.drawingArea[0], [trace, vert],\n                         layout, this.config);\n\n    this.drawingArea[0].on('plotly_click', ({points}) => {\n      const time_s = 60 * 60 * points[0].x;\n      const detail = {t0: time_s - 2 * epochDuration, dt: 5 * epochDuration};\n      window.dispatchEvent(new CustomEvent(events.TIME_CHANGED, { detail: detail}));\n    });\n  }\n\n  setVert (t0) {\n    // compute t0 in hours\n    let window_start = t0 / 60 / 60;\n    Plotly.restyle(this.drawingArea[0], {'x': [[window_start, window_start]]}, 1);\n  }\n\n};\n\nwindow.customElements.define(HTML_ID, HypnogramElement);\n\n\n//# sourceURL=webpack:///./code/hypnogram_elem.js?");

/***/ }),

/***/ "./code/keyboard.js":
/*!**************************!*\
  !*** ./code/keyboard.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nconst events = __webpack_require__(/*! custom_events */ \"./code/custom_events.js\");\n\nclass Keyboard {\n\n  constructor(target=window) {\n    this.keymap = {};\n    target.addEventListener(\"keydown\", (k) => {\n      try {\n        const callbacks = this.keymap[k.key];\n        if(!callbacks) {\n          return;\n        }\n        for (let callback of callbacks) {\n          callback();\n        }\n      } catch (err) {\n        console.warn(\"In Keyboard ->\", k.key, \":\", err);\n      };\n    });\n    target.addEventListener(events.REGISTER_KEY, event => {\n      event.stopPropagation();\n      const {key, callback} = event.detail;\n      this.register(key, callback);\n    });\n    target.addEventListener(events.UNREGISTER_KEY, event => {\n      event.stopPropagation();\n      const {key, callback} = event.detail;\n      this.unregister(key, callback);\n    });\n  }\n\n  register(key, callback) {\n    if(key in this.keymap) {\n      this.keymap[key].push(callback);\n    } else {\n      this.keymap[key] = [callback];\n    }\n  }\n\n  unregister(key, callback) {\n    const i = this.keymap[key].indexOf(callback);\n    if (i > -1) {\n      this.keymap[key].splice(i, 1);\n    }\n  }\n\n  remove_all() {\n    this.keymap = {};\n  }\n\n};\n\nmodule.exports = {\n  'Keyboard': Keyboard\n};\n\n\n//# sourceURL=webpack:///./code/keyboard.js?");

/***/ }),

/***/ "./code/menubar.js":
/*!*************************!*\
  !*** ./code/menubar.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* global  HTMLElement,window */\n\n\nconst events = __webpack_require__(/*! custom_events */ \"./code/custom_events.js\");\nconst AboutDialog = __webpack_require__(/*! dialogs */ \"./code/dialogs.js\").AboutDialog;\nconst $ = window.jQuery;\nconst bioimagesuiteweb = window.bioimagesuiteweb;\nconst webutil = bioimagesuiteweb.webutil;\nconst pwautils = __webpack_require__(/*! pwautils */ \"./code/pwautils.js\");\n\nconst HTML_ID = 'menu-bar';\n\nconst MENUBAR_NAME = \"menubar\";\n\nconst html=`\n<nav class=\"navbar navbar-default navbar-fixed-top\">\n  <div class=\"container-fluid\" id=\"bismenucontainer\">\n    <div class=\"navbar-header\" id=\"bismenuheader\" >\n      <button type=\"button\" class=\"navbar-toggle collapsed\" data-toggle=\"collapse\" data-target=\"#bismenu\">\n        <span class=\"sr-only\">Toggle navigation</span>\n        <span class=\"icon-bar\"></span>\n        <span class=\"icon-bar\"></span>\n        <span class=\"icon-bar\"></span>\n      </button>\n      <img src=\"images/logo-xl.png\" height=\"50px\" style=\"margin:10px\">\n    </div>\n    <div class=\"collapse navbar-collapse\" id=\"bismenu\">\n      <ul class=\"nav navbar-nav\" id=\"bismenuparent\" name=\"${MENUBAR_NAME}\"></ul>\n    </div>\n  </div>\n</nav>`;\n\nclass MenubarElement extends HTMLElement {\n\n  constructor() {\n    super();\n    this.aboutdialog = null;\n  }\n    \n  connectedCallback() {\n    let elem = $(html);\n    this.appendChild(elem[0]);\n    this.menubar = elem.find(`[name='${MENUBAR_NAME}']`);\n    // Add PWA item in help menu\n    // Create the Help Menu\n    let hmenu = webutil.createTopMenuBarMenu(\"Help\", this.menubar);\n    webutil.createMenuItem(hmenu, 'About this Application',\n      () => this.about());\n    if (!pwautils.inPWA()) {\n      // Register the service worker and if possible optionally add an\n      // 'install application' button to this\n      pwautils.registerServiceWorker();\n      pwautils.addInstallButton(hmenu);\n    }\n  }\n\n  about() {\n    if (this.aboutdialog === null) {\n      // create about dialog\n      this.aboutdialog = new AboutDialog();\n    }\n    //\tshow about dialog\n    this.aboutdialog.show();\n  }\n\n}\n\nwindow.customElements.define(HTML_ID, MenubarElement);\n\n\n//# sourceURL=webpack:///./code/menubar.js?");

/***/ }),

/***/ "./code/pwautils.js":
/*!**************************!*\
  !*** ./code/pwautils.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Utilities for Progressive web applications\n */\nconst bioimagesuiteweb = window.bioimagesuiteweb;\nconst webutil = bioimagesuiteweb.webutil;\n\n\n/** Keep track of the install button and related elements */\nconst internal = {\n  installElements: null,\n  deferredInstallPrompt: null,\n};\n\n/** Register the service worker \n * This code derives from auto-generated code from \n * PWABuilder -- www.pwabuilder.com\n */\n\nlet registerServiceWorker = () => {\n  // Register the service worker\n  if (!navigator.serviceWorker.controller) {\n    //Register the ServiceWorker\n    navigator.serviceWorker.register('serviceworker.js', {\n      scope: './'\n    }).then((reg) => console.log(`\n      [pwautils] Service worker has been registered for scope: ${reg.scope}`));\n  }\n};\n\n/** Add install button if possible\n * @param{Menu} helpmenu - the menu to add the button to\n */\n// See https://developers.google.com/web/fundamentals/app-install-banners/\nlet addInstallButton = function(helpmenu) {\n  // Add a button to install the application\n  window.addEventListener('beforeinstallprompt', (evt) => {\n    console.log(`[pwautils: event 'beforeinstallprompt'] ${evt}`);\n    evt.preventDefault();\n    if (internal.installElements === null) {\n      evt.preventDefault();\n      // Stash the event so it can be triggered later.\n      internal.deferredInstallPrompt = evt;\n      internal.deferredInstallPrompt.userChoice.then((choiceResult) => {\n        if (choiceResult.outcome === 'accepted') {\n          internal.deferredInstallPrompt = null;\n          for (let i=0; i < internal.installElements.length; i++)\n            internal.installElements[i].remove();\n          internal.installElements = null;\n        }\n      });\n\n      internal.installElements = [\n        webutil.createMenuItem(helpmenu, ''), // separator\n        webutil.createMenuItem(helpmenu, 'Install internal Application as PWA',\n             () => internal.deferredInstallPrompt.prompt())\n      ];\n    } else {\n      internal.deferredInstallPrompt = evt;\n    }\n  });\n};\n\n\n// https://stackoverflow.com/questions/52000972/pwa-fixed-screensize\nlet inPWA = function() {\n  return window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone === true;\n};\n\n// Export functions\nmodule.exports = {\n  addInstallButton,\n  registerServiceWorker,\n  inPWA\n};\n\n\n//# sourceURL=webpack:///./code/pwautils.js?");

/***/ }),

/***/ "./code/scoring_config.js":
/*!********************************!*\
  !*** ./code/scoring_config.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* global  HTMLElement,window */\n\n\n\nconst events = __webpack_require__(/*! custom_events */ \"./code/custom_events.js\");\n\nconst DEFAULTSTAGEMAP = {\n  'W': 'Wake',\n  'N': 'Non REM',\n  'R': 'REM'\n};\n\nclass ScoringConfig {\n\n  constructor(callbackFactory) {\n    // TODO remove unused properties\n    this.stages = new Set();\n    this.keyboardMap = {};\n    this.callbackFactory = callbackFactory;\n    this.targets = [window];\n  }\n\n  connectedCallback() {\n    for (let key in DEFAULTSTAGEMAP) {\n      const stage = DEFAULTSTAGEMAP[key];\n      this.defineStage(stage);\n      this.mapKey(key, stage);\n    }\n  }\n\n  defineStage (stage) {\n    this.stages.add(stage);\n  }\n\n  mapKey (key, stage) {\n    // if the stage is defined, or the key is already set\n    if (!this.stages.has(stage) || this.keyboardMap.hasOwnProperty(key)) {\n      return false;\n    }\n    this.keyboardMap[key] = stage;\n    const detail = {\n      key: key,\n      callback: this.callbackFactory(key, stage)\n    };\n    for (let target of this.targets) {\n      target.dispatchEvent(new CustomEvent(events.REGISTER_KEY, {detail: detail}));\n    }\n    return true;\n  }\n\n  deleteStage (stage) {\n    this.stages.delete(stage);\n    const deletableKeys = [];\n    for (let key in this.keyboardMap) {\n      if (stage === this.keyboardMap[value]) {\n        deletableKeys.push(key);\n      }\n    }\n    for (let key of deletableKeys) {\n      this.keyboardMap.delete(key);\n    }\n  }\n}\n\nmodule.exports = ScoringConfig;\n\n\n//# sourceURL=webpack:///./code/scoring_config.js?");

/***/ }),

/***/ "./code/signal_source.js":
/*!*******************************!*\
  !*** ./code/signal_source.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* global  HTMLElement,window */\n\n\n\nconst { UniversalDate } = __webpack_require__(/*! utils */ \"./code/utils.js\");\nconst { FilteredEDF } = __webpack_require__(/*! filtered_edf */ \"./code/filtered_edf.js\");\n\nclass EDFSource {\n\n  constructor() {\n    this.source = new FilteredEDF();\n  }\n\n  async fromFile(f) {\n    if (!this.source) {\n      this.source = new FilteredEDF();\n    }\n    // this.source = new edfjs.EDF();\n    if(typeof f === \"string\") {\n      // If `f` is a file path, we assume that node module `fs` has been\n      // imported into the global namespace.  We use it to read the file.\n      const file = fs.readFileSync(f);\n      this.source.read_buffer(file.buffer);\n    } else {\n      await this.source.from_file(f, false);\n    }\n  }\n\n  cacheChannel (label, cacheLabel, srNew) {\n    return this.source.cacheChannel(label, cacheLabel, srNew);\n  }\n\n  get channels () {\n    return this.source.channels;\n  }\n\n  get sampling_rate () {\n    return this.source.sampling_rate;\n  }\n\n  set filename (name) {\n    this.source.filename = name;\n  }\n\n  get filename() {\n    return this.source.filename;\n  }\n\n  get startdatetime() {\n    return new UniversalDate(this.source.startdatetime);\n  }\n\n  get_physical_samples(t0, dt, labels) {\n    return this.source.get_physical_samples( t0, dt, labels);\n  }\n\n  relative_date(reltime_ms) {\n    return new UniversalDate(this.source.relative_date(reltime_ms));\n  }\n\n  get duration() {\n    return this.source.duration;\n  }\n\n  get labels() {\n    if (!this._labels) {\n      this._labels = [];\n      for (let channel of this.channels) {\n        this._labels.push(channel.label);\n      }\n    }\n    return this._labels;\n  }\n\n  sleepStages() {\n    return {};\n  }\n\n  annotations() {\n    return {};\n  }\n\n  isValid () {\n    if (!this.duration) {\n      return false;\n    }\n    if (!this.channels.length) {\n      return false;\n    }\n    return true;\n  }\n\n}\n\nmodule.exports = {\n  EDFSource: EDFSource,\n};\n\n\n//# sourceURL=webpack:///./code/signal_source.js?");

/***/ }),

/***/ "./code/signal_source_elem.js":
/*!************************************!*\
  !*** ./code/signal_source_elem.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* global  HTMLElement,window,sampleFileURL */\n\n\n\nconst events = __webpack_require__(/*! custom_events */ \"./code/custom_events.js\");\nconst dialogs = __webpack_require__(/*! dialogs */ \"./code/dialogs.js\");\nconst bioimagesuiteweb = window.bioimagesuiteweb;\nconst webutil = bioimagesuiteweb.webutil;\nconst webfileutil = bioimagesuiteweb.webfileutil;\nconst {EDFSource} = __webpack_require__(/*! signal_source */ \"./code/signal_source.js\");\nconst {UniversalDate, isEmpty} = __webpack_require__(/*! utils */ \"./code/utils.js\");\nconst config = __webpack_require__(/*! config */ \"./code/config.js\");\n\nconst HTML_ID = 'signal-source';\nconst NOT_OPEN_TEXT = 'No file open';\n\nclass SignalSourceElement extends HTMLElement {\n\n  get html() {\n    return `<div class='${HTML_ID}'><p class='${HTML_ID}' /></div>`;\n  }\n\n  constructor() {\n    super();\n    this.source = null;\n    this.t0 = 0.0; // sec.\n    this._dt = config.windowDuration; // sec.\n    this.step = this.dt / 10;\n  }\n\n  connectedCallback() {\n    const elem = $(this.html);\n    this.appendChild(elem[0]);\n    this.fileDescriptor = elem.find(`p.${HTML_ID}`).last();\n    this.fileDescriptor.html(NOT_OPEN_TEXT);\n    this.addFileMenu();\n    // * update signals view if time changed\n    this.timeChangedCallback = ({detail}) => {\n      if (!(detail.t0 === undefined || detail.t0 === null)) {\n        this.t0 = detail.t0;\n      }\n      this.dt = detail.dt || this.dt;\n      this.updateSignals();\n    };\n    window.addEventListener(events.TIME_CHANGED, this.timeChangedCallback);\n    this.connectWithSignalView();\n  }\n\n  get signalView() {\n    return document.querySelector(this.getAttribute('signal-view'));\n  }\n\n  get annotationListElem() {\n    return document.querySelector(this.getAttribute('annotation-list'));\n  }\n\n  connectWithSignalView () {\n    if (!this.signalView) {\n      return;\n    }\n    this.signalView.addEventListener('wheel', (e) => {\n      e.stopPropagation();\n      if(e.shiftKey) {\n        this.dt = Math.max(5, this.dt * (1 + e.deltaY / 360));\n        this.updateSignals();\n      } else {\n        const t0 = Math.max(0, this.t0 + e.deltaY / 90 * this.step);\n        window.dispatchEvent(new CustomEvent(events.TIME_CHANGED, {detail: {t0: t0}}));\n      }\n    });\n  }\n\n  focusOnAnnotation(annotation) {\n    const t0 = 0.001 * (annotation.datetime.ms - this.source.startdatetime.ms),\n          dt = annotation.dt_s;\n    const update = {t0: (t0 + dt / 2) - this.dt / 2};\n    window.dispatchEvent(new CustomEvent(events.TIME_CHANGED, {detail: update}));\n  }\n\n  get menubar() {\n    // return html element given as attribute `menubar`\n    const mb = document.querySelector(this.getAttribute('menubar'));\n    return mb ? mb.menubar : null;\n  }\n\n  addFileMenu() {\n    if(this.menubar === null) {\n      // no menubar present on the page\n      return;\n    }\n    let fmenu = webutil.createTopMenuBarMenu(\"File\", this.menubar);\n    // create menu item to open local files\n    webfileutil.createFileMenuItem(fmenu, 'Open local file',\n      // file dialog callback\n      async (file) => this.openLocalEDF(file),\n      // file dialog options\n      { title: 'Load .edf file',\n      save: false, suffix: \".edf\",\n      filters: [{extensions: [ \"edf\"]}] }\n    );\n    webutil.createMenuItem(fmenu, 'Open from url', () => {\n      this.urlDialog.url = sampleFileURL;\n      this.urlDialog.show();\n    });\n    // create menu to view/select/build channel derivation\n    webutil.createMenuItem(fmenu, 'Close', () => this.closeSource() );\n    webutil.createMenuItem(fmenu, '');\n    webutil.createMenuItem(fmenu, 'Select channels..', () => this.derivationDialog.show() );\n  }\n\n  get urlDialog () {\n    if (!this._urlDialog) {\n      const callback = async (url) => {\n        await this.openRemoteEDF(url);\n        const success = this.source.isValid();\n        if (success) {\n          return success;\n        } else {\n          this.closeSource();\n          return false;\n        }\n      };\n      this._urlDialog = new dialogs.UrlDialog(callback);\n    }\n    return this._urlDialog;\n  }\n\n  async openRemoteEDF (url) {\n    const blob = await fetch(url).then(r => r.blob());\n    const buffer = await blob.arrayBuffer();\n    this.source = new EDFSource();\n    await this.source.source.read_buffer(buffer);\n    this.source.filename = url;\n    this.fileDescriptor.html(this.source.filename);\n    this.buildFromSource();\n  }\n\n  get derivationDialog () {\n    if (!this._derivationDialog) {\n      // Add event callbacks:\n      // * update signals view if channel configuration changed\n      this._derivationDialog = new dialogs.DerivationDialog( label => {\n        for(let channel of this.source.channels) {\n          if(channel.label === label) {\n            channel.selected = !channel.selected;\n            this.updateSignals();\n            return;\n          }\n        }\n      });\n    }\n    return this._derivationDialog;\n  }\n\n  /** Close the data source that is currently opened\n   */\n  closeSource () {\n    this.unregisterNavigation();\n    try {\n      window.dispatchEvent(new CustomEvent(events.CLOSE_FILE));\n      this.dispatchEvent(new CustomEvent(events.CLOSE_FILE));\n    } catch (err) {\n      console.log(err);\n    }\n    this._closeSource();\n  }\n\n  _closeSource() {\n    this.fileDescriptor.html(NOT_OPEN_TEXT);\n    this.source = null;\n  }\n\n  get selectedLabels() {\n    // return list of channel labels with flag `selected=true`\n    let selected = [];\n    for (let channel of this.source.channels) {\n      if (channel.selected) {\n        selected.push(channel.label);\n      }\n    }\n    return selected;\n  }\n\n  async updateSignals () {\n    if(!(this.source && this.selectedLabels.length)) {\n      return;\n    }\n    const signalByLabel = await this.source.get_physical_samples(\n      this.t0, this.dt, this.selectedLabels);\n    // while `await`, the signal source might be dealocated.\n    if(!this.source) {\n      return;\n    }\n    // add UTC time to signal-update event\n    // time: webbrowser `Date` object\n    const update = {\n      time: this.source.relative_date(1000 * this.t0),\n      data: {}\n    };\n    // Add signals+sampling rates to event\n    for(let label in signalByLabel) {\n      update.data[label] = {\n        samples: signalByLabel[label],\n        rate: this.source.sampling_rate[label]\n      };\n    }\n    window.dispatchEvent(new CustomEvent(events.SIGNAL_UPDATE, {detail: update}));\n    // update annotations\n    this.annotationListElem.dispatchUpdate(update.time, this.dt);\n  }\n\n  get t0() {\n    return this._t0;\n  }\n\n  set t0(t0) {\n    return this._t0 = Math.max(0, t0);\n  }\n\n  get dt() {\n    return this._dt;\n  }\n\n  set dt(d) {\n    if (!this.source) {\n      return;\n    }\n    // window no smaller than 4 seconds\n    this._dt = Math.max(d, 4);\n    // update the step to be 10th of window but no smaller than 1 second\n    this.step = Math.max(Math.floor(this.dt / 10), 1);\n  }\n\n  registerNavigation () {\n    this.keymapCallbacks = {\n      'ArrowRight': () => {\n          const t0 = Math.max(0, this.t0 + this.step);\n          const event = new CustomEvent(\n            events.TIME_CHANGED, {detail: {t0: t0}});\n          window.dispatchEvent(event);\n        },\n      'ArrowLeft': () => {\n          window.dispatchEvent(new CustomEvent(events.TIME_CHANGED,\n            {detail: {t0: Math.max(0, this.t0 - this.step)}}));\n        },\n      'ArrowDown': () => {\n          this.dt = this.dt / 0.7;\n          this.updateSignals();\n        },\n      'ArrowUp': () => {\n          this.dt = Math.max(4, this.dt * 0.7);\n          this.updateSignals();\n        }\n    };\n    for (let key in this.keymapCallbacks) {\n      const callback = this.keymapCallbacks[key];\n      window.dispatchEvent(new CustomEvent(\n        events.REGISTER_KEY, {detail: {key: key, callback: callback}}));\n    }\n  }\n\n  unregisterNavigation () {\n    for (let key in this.keymapCallbacks) {\n      const callback = this.keymapCallbacks[key];\n      window.dispatchEvent(new CustomEvent(\n        events.UNREGISTER_KEY, {detail: {key: key, callback: callback}}));\n    }\n  }\n\n  /** Open an .edf file from the local disc\n   */\n  async openLocalEDF (filename) {\n    this.source = new EDFSource();\n    await this.source.fromFile(filename);\n    this.fileDescriptor.html(this.source.filename);\n    this.buildFromSource();\n  }\n\n  /** Build UI after loading a new signal source\n   *\n   * Notify UI of channel list, update signals views, and register keyboard\n   * shortcuts for time-window navigation.\n   */\n  async buildFromSource() {\n    // exchange `true` to show all signals in the file upon loading\n    for (let channel of this.source.channels) {\n      channel.selected = false;\n    }\n    this.derivationDialog.choices = this.source.labels;\n    this.derivationDialog.show();\n    // send sleep stages if available\n    let stages = await this.source.sleepStages();\n    if (!isEmpty(stages)) {\n      window.dispatchEvent(new CustomEvent(\n        events.HYPNOGRAM_UPDATE, {detail: stages}));\n    }\n    // send annotations if available\n    let annots = await this.source.annotations();\n    if(!isEmpty(annots)) {\n      let start = this.source.startdatetime.ms;\n      for(let i=0; i < annots.t0.length; i++) {\n        let datetime = new UniversalDate(1000 * annots.t0[i] + start);\n        this.annotationListElem.addAnnotation(\n          datetime, annots.dt[i], annots.label[i]);\n      }\n    }\n    // trigger dt.setter\n    this.dt = this.dt;\n    this.updateSignals();\n    this.registerNavigation();\n    this.dispatchEvent(new CustomEvent(events.OPEN_FILE, {\n      detail: {\n        startdatetime: this.source.startdatetime,\n        filename: this.source.filename,\n        duration: this.source.duration\n      }\n    }));\n  }\n}\n\nwindow.customElements.define(HTML_ID, SignalSourceElement);\n\n\n//# sourceURL=webpack:///./code/signal_source_elem.js?");

/***/ }),

/***/ "./code/signal_view.js":
/*!*****************************!*\
  !*** ./code/signal_view.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nconst Plotly = window.Plotly;\nconst $ = window.jQuery;\nconst events = __webpack_require__(/*! custom_events */ \"./code/custom_events.js\");\nconst {UniversalDate, isEmpty} = __webpack_require__(/*! utils */ \"./code/utils.js\");\nconst config = __webpack_require__(/*! config */ \"./code/config.js\");\nconst colors = __webpack_require__(/*! custom_colors */ \"./code/custom_colors.js\");\n\nconst HTML_ID = 'signal-view';\n\nconst TIMESTAMP_ID = 'timestamp';\nconst DRAWINGAREA_ID = 'drawingArea';\n\nclass SignalViewElement extends HTMLElement {\n\n  get html() {\n    return `\n      <div>\n      <span>Heres some text</span>\n        <div class='${HTML_ID}' id='${DRAWINGAREA_ID}'></div>\n        <p class='${HTML_ID}' id='${TIMESTAMP_ID}'></p>\n      </div>`;\n  }\n\n  constructor() {\n    super();\n    this.resultsdialog = null;\n    this.px_per_signal = 100;\n    this.config = {\n      displayModeBar: false,\n    };\n    this.layouts = {};\n    this.annotCandidate = {};\n  }\n\n  connectedCallback() {\n    const elem = $(this.html);\n    this.appendChild(elem[0]);\n    this.drawingArea = elem.find(`[id='${DRAWINGAREA_ID}']`);\n    this.timestamp = elem.find(`[id='${TIMESTAMP_ID}']`)[0];\n\n    window.addEventListener(events.SIGNAL_UPDATE, ({detail}) => this.update(detail));\n    // Remove all data from widgets when closing the file\n    window.addEventListener(events.CLOSE_FILE, () => {\n      this.timestamp.innerHTML = '';\n      this.drawingArea.text('');\n    });\n    this.connectAnnotationListElem(5);\n  }\n\n  connectAnnotationListElem (tries) {\n    if (tries) {\n      const annotListElem = this.annotationListElem;\n      if (annotListElem) {\n        annotListElem.addEventListener(events.ANNOTS_UPDATE, ({detail}) => this.addAnnots(detail));\n      } else {\n        tries--;\n        setTimeout( () => this.connectAnnotationListElem(tries), 123);\n      }\n    }\n  }\n\n  get annotationListElem () {\n    return document.querySelector(this.getAttribute('annotations-list'));\n  }\n\n  layout(label=\"\") {\n    if(label === \"\") {\n      // return master layout\n      return {\n        dragmode: 'select',\n        hovermode: false,\n        showlegend: false,\n        xaxis: {\n          rangemode: 'nonnegative',\n          title: \"relative time (sec.)\",\n          tick0: 0,\n          dtick: 1\n        },\n        margin: { t: 0, b: 30, l: 40, r: 20 }\n      };\n    } else if(label in this.layouts) {\n      // return the cached layout for `label`\n      return this.layouts[label];\n    } else {\n      // construct and return a new layout for `label`\n      const layout = {\n        yaxis: {\n          zeroline: false,\n          title: label,\n        },\n        data: {\n          mode: 'lines',\n          line: {\n            color: \"rgb(0.2,0.2,0.2)\",\n            width: 1\n          }\n        }\n      };\n      if(label !== 'annotations') {\n        // all labels except annotations get a fixed range\n        layout.yaxis.range = config.yrange;\n      } else {\n        layout.yaxis.title = null;\n        layout.yaxis.showticklabels = false;\n      }\n      this.layouts[label] = layout;\n      return this.layout(label);\n    }\n  }\n\n  update (data) {\n    this.timestamp.innerHTML = data.time.datetimestr;\n    let signals = data.data;\n    if (isEmpty(signals)) {\n      // no signals provided; clear the drawing area\n      this.drawingArea.text(\"\");\n      return;\n    }\n    // all signals + 1 annotation axis\n    const numSignals = Object.keys(signals).length + 1;\n    this.drawingArea.css('height', this.px_per_signal * numSignals);\n    const traces = [];\n    const masterLayout = this.layout();\n    const annotFraction = 0.2 / numSignals;\n    const domain = [0, annotFraction];\n    for (let s = 1; s <= numSignals; s++) {\n      domain.push(annotFraction + (1 - annotFraction) * s / numSignals);\n    }\n    let c1 = numSignals;\n    let duration = 1;\n    for (let label in signals) {\n      const signal = signals[label],\n            layout = this.layout(label),\n            data = layout.data;\n      const dt = signal.samples.length / signal.rate;\n      duration = dt > duration ? dt: duration;\n      data.x = Float32Array.from(new Array(signal.samples.length), (val, idx) => idx / signal.rate);\n      data.y = signal.samples;\n      data.yaxis = \"y\" + c1;\n      traces.push(data);\n      masterLayout['xaxis'+c1] = { anchor: data.yaxis };\n      masterLayout['yaxis'+c1] = layout.yaxis;\n      masterLayout['yaxis'+c1].domain = [domain[c1-1], domain[c1]];\n      c1--;\n    }\n    // Add annotations layout to drawing area\n    masterLayout['xaxis1'] = { anchor: \"y1\" };\n    masterLayout['yaxis1'] = this.layout('annotations').yaxis;\n    masterLayout['yaxis1'].domain = [0, domain[1]];\n    masterLayout.xaxis.range = [0, duration];\n\n    // Plot to drawing area\n    Plotly.newPlot(DRAWINGAREA_ID, traces, masterLayout, this.config);\n\n    // listen for annotation events\n    this.drawingArea[0].on('plotly_selected', (event) => {\n      if(event) {\n        this.initAnnotationCandidate(event.range.x, data.time);\n        // make annotation list visible\n        this.annotlist.css('visibility', 'visible');\n      }\n    });\n  }\n\n  /**\n   * @param annots: list of annotations to add to yaxis1\n   */\n  async addAnnots(annots) {\n    const traces = [];\n    const labels = {\n      x: [],\n      y: [],\n      text: [],\n      mode: 'text',\n      yaxis: 'y1',\n      textfont: {\n        color: 'black',\n        size: 14\n      },\n    };\n    // precompute line styles for each label\n    const linestyle = {};\n    for (let label in colors.annotations.line) {\n      const color = colors.annotations.line[label];\n      linestyle[label] = {color: color, width: 0.5};\n    }\n    for(let annot of annots) {\n      const x = [annot.trel, annot.trel + annot.dt],\n            y = [0, 1],\n            label = annot.label;\n      const fillcolor = annot.selected ? colors.annotations.fill.selected : colors.annotations.fill.unselected;\n      traces.push({\n        x: [x[0], x[1], x[1], x[0], x[0]],\n        y: [y[1], y[1], y[0], y[0], y[1]],\n        mode: 'lines',\n        fill: 'toself',\n        yaxis: 'y1',\n        fillcolor: fillcolor[label],\n        line: linestyle[label]\n      });\n      labels.x.push(0.5 * (x[0] + x[1]));\n      labels.y.push(0.5 * (y[0] + y[1]));\n      labels.text.push(label);\n    }\n    if(traces.length > 0) {\n      Plotly.addTraces(DRAWINGAREA_ID, traces);\n      Plotly.addTraces(DRAWINGAREA_ID, labels);\n    }\n  }\n};\n\nwindow.customElements.define(HTML_ID, SignalViewElement);\n\n\n//# sourceURL=webpack:///./code/signal_view.js?");

/***/ }),

/***/ "./code/utils.js":
/*!***********************!*\
  !*** ./code/utils.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// These are hints for JSHint\n//*global baseURL*/\n/* utils.js\n * A selection of helper functions for EEG Review\n */\n\nfunction isEmpty(obj) {\n  /* Return `true` if obj is '{}' */\n  for (let key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/* convert base-64 string to 32-bit float array\n/* Base64 string converted to a char array\n */\nfunction b642f32(b64) {\n  b64 = atob(b64);\n  // How many floats can be made, but be even\n  let blobsize = b64.length / Float32Array.BYTES_PER_ELEMENT;\n  // ArrayBuffer/DataView to convert 4 bytes into 1 float\n  let dView\t= new DataView(new ArrayBuffer(Float32Array.BYTES_PER_ELEMENT));\n  // Final Output at the correct size\n  let f32 = new Float32Array(blobsize);\n  // position in f32\n  let p = 0;\n  for(let j = 0; j < blobsize; j++) {\n    p = j * 4;\n    dView.setUint8(0, b64.charCodeAt(p));\n    dView.setUint8(1, b64.charCodeAt(p+1));\n    dView.setUint8(2, b64.charCodeAt(p+2));\n    dView.setUint8(3, b64.charCodeAt(p+3));\n    f32[j] = dView.getFloat32(0, true);\n  }\n  return f32;\n}\n\n/** return `Date` object as formatted string\n * @param(dt): `Date` object\n */\nfunction date2str(dt) {\n  const hrs = dt.getHours(),\n        nts = dt.getMinutes(),\n        sec = dt.getSeconds(),\n        sub = dt.getMilliseconds();\n\n  return [\n    (hrs>9 ? '' : '0') + hrs,\n    (nts>9 ? '' : '0') + nts,\n    (sec>9 ? '' : '0') + sec\n  ].join(':');\n}\n\nclass UniversalDate extends Date {\n\n  constructor(obj) {\n    const dateWithOffset = new Date(obj);\n    const offset_ms = dateWithOffset.getTimezoneOffset() * 60 * 1000;\n    super(dateWithOffset.getTime() - offset_ms);\n    this.offset_ms = offset_ms;\n  }\n\n  get timestr() {\n    let date = new Date(this.ms + this.offset_ms);\n    return date2str(date);\n  }\n\n  get datetimestr() {\n    let date = new Date(this.ms + this.offset_ms);\n    return date2str(date);\n  }\n\n  get ms() {\n    return super.getTime() + this.offset_ms;\n  }\n\n  plus(ms) {\n    return new UniversalDate(this.ms + ms);\n  }\n\n}\n\nfunction concatenate(ArrayType, arrays) {\n  let length = 0;\n  for (let arr of arrays) {\n    length += arr.length;\n  }\n  const joined = new ArrayType(length);\n  let offset = 0;\n  for (let arr of arrays) {\n    joined.set(arr, offset);\n    offset += arr.length;\n  }\n  return joined;\n}\n\nfunction argmax (arr) {\n  var max=arr[0], imax=0;\n  for (var i = 1; i < arr.length; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n      imax = i;\n    }\n  }\n  return imax;\n}\n\n\nmodule.exports = {\n  isEmpty: isEmpty,\n  b642f32: b642f32,\n  UniversalDate: UniversalDate,\n  concatenate: concatenate,\n  argmax: argmax\n};\n\n\n//# sourceURL=webpack:///./code/utils.js?");

/***/ }),

/***/ "./node_modules/edfjs/src/channel.js":
/*!*******************************************!*\
  !*** ./node_modules/edfjs/src/channel.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nconst utils = __webpack_require__(/*! ./utils */ \"./node_modules/edfjs/src/utils.js\");\nconst toString = utils.toString;\n\nclass Channel {\n\n  constructor() {\n    this.fields = {\n      label: [toString, 16],\n      channel_type: [toString, 80],\n      physical_dimension: [toString, 8],\n      physical_minimum:\t[Number, 8],\n      physical_maximum: [Number, 8],\n      digital_minimum: [Number, 8],\n      digital_maximum: [Number, 8],\n      prefiltering: [toString, 80],\n      num_samples_per_record: [Number, 8],\n      reserved: [toString, 32]\n    };\n  }\n\n  init(num_records, record_duration) {\n    if (this.num_samples_per_record == null) {\n      throw 'init called on uninitialized channel';\n    }\n    this.blob = new Float32Array(num_records * this.num_samples_per_record);\n    this.scale = (this.physical_maximum - this.physical_minimum) /\n                 (this.digital_maximum  - this.digital_minimum);\n    this.offset = this.physical_maximum / this.scale - this.digital_maximum;\n    this.sampling_rate = this.num_samples_per_record / record_duration;\n  }\n\n  digital2physical(d) {\n    return this.scale * (d + this.offset);\n  }\n\n  set_record(record, digi) {\n    const start = record * this.num_samples_per_record;\n    for (var i=0; i < this.num_samples_per_record; i++) {\n      this.blob[start+i] = this.digital2physical(digi[i]);\n    }\n  }\n\n  get_physical_samples(t0, dt, n) {\n    n = n || dt*this.sampling_rate;\n    const start = t0*this.sampling_rate;\n    return this.blob.slice(start, start+n);\n  }\n}\n\nmodule.exports = Channel;\n\n\n//# sourceURL=webpack:///./node_modules/edfjs/src/channel.js?");

/***/ }),

/***/ "./node_modules/edfjs/src/edf.js":
/*!***************************************!*\
  !*** ./node_modules/edfjs/src/edf.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nconst utils = __webpack_require__(/*! ./utils */ \"./node_modules/edfjs/src/utils.js\");\nconst Channel = __webpack_require__(/*! ./channel */ \"./node_modules/edfjs/src/channel.js\");\n\nconst toString = utils.toString;\n\nclass EDF {\n\n  constructor() {\n    this.fields = {\n      version: [toString, 8],\n      pid: [toString, 80],\n      rid: [toString, 80],\n      startdate: [toString, 8],\n      starttime: [toString, 8],\n      num_header_bytes: [Number, 8],\n      reserved: [toString, 44],\n      num_records: [Number, 8],\n      record_duration: [Number, 8],\n      num_channels: [Number, 4]\n    };\n    this.header_bytes = 256;\n    this.bytes_per_sample = 2;\n    this.channels = [];\n  }\n\n  get_physical_samples(t0=0, dt=null, channels=null, n=null) {\n    if (t0 === null) {\n      t0 = 0;\n    }\n    if (dt === null && n === null) {\n      dt = this.duration;\n    }\n    if (channels === null) {\n      channels = [];\n      for (let label in this.channel_by_label) {\n        channels.push(label);\n      }\n    }\n    return new Promise((resolve) => {\n      const data = {};\n      for(let label of channels) {\n        data[label] = this.channel_by_label[label].get_physical_samples(t0, dt, n);\n      }\n      resolve(data);\n    });\n  }\n\n  from_file(file, header_only=false) {\n    return new Promise( (resolve) => {\n      const reader = new FileReader();\n      this.filename = file.name;\n      reader.onload = (evt) => {\n        this.read_buffer(evt.target.result, header_only);\n        resolve(this);\n      };\n      reader.readAsArrayBuffer(file);\n    });\n  }\n\n  relative_date(milliseconds) {\n    return new Date(this.relative_time(milliseconds));\n  }\n\n  read_buffer(buffer, header_only=false) {\n    // header\n    const hdr = utils.string_from_buffer(buffer, 0, this.header_bytes);\n    this.read_header_from_string(hdr);\n    if (this.num_channels == 0) {\n      return null;\n    }\n    // channels\n    const ch = utils.string_from_buffer(buffer, this.header_bytes, this.num_header_bytes);\n    this.read_channel_header_from_string(ch);\n    this.check_blob_size(buffer);\n    // blob\n    if(!header_only) {\n      this.read_blob_from_buffer(buffer);\n    }\n  }\n\n  read_header_from_string(string) {\n    let start = 0;\n    for (let name in this.fields) {\n      const type = this.fields[name][0];\n      const end = start + this.fields[name][1];\n      this[name] = type(string.substring(start, end));\n      start = end;\n    }\n    this.startdatetime = utils.parseDateTime(this.startdate, this.starttime);\n  }\n\n  read_channel_header_from_string(string) {\n    if(this.num_channels === 0) {\n      return;\n    }\n    for (let c=0; c < this.num_channels; c++) {\n      this.channels.push(new Channel());\n    }\n    let start = 0;\n    const channel_fields = this.channels[0].fields;\n    for (let name in channel_fields) {\n      const type = channel_fields[name][0];\n      const len = channel_fields[name][1];\n      for (let c=0; c < this.num_channels; c++) {\n        const end = start + len;\n        this.channels[c][name] = type(string.substring(start, end));\n        start = end;\n      }\n    }\n    this.channel_by_label = {};\n    for(let channel of this.channels) {\n      this.channel_by_label[channel.label] = channel;\n    }\n  }\n\n  check_blob_size(buffer) {\n    let samples_per_record = 0;\n    for (let c=0; c < this.num_channels; c++) {\n      samples_per_record += this.channels[c].num_samples_per_record;\n    }\n    const expected_samples = samples_per_record * this.num_records;\n    const samples_in_blob = (buffer.byteLength - this.num_header_bytes) / 2;\n    this.duration = this.record_duration * samples_in_blob / samples_per_record;\n    utils.assert(samples_in_blob == expected_samples,\n                 `Header implies ${expected_samples} samples; ${samples_in_blob} found.`);\n    return samples_in_blob;\n  }\n\n  read_blob_from_buffer(buffer) {\n    let record_channel_map = [0];\n    for (let c=0; c < this.num_channels; c++) {\n      record_channel_map.push(\n        record_channel_map[c] + this.channels[c].num_samples_per_record);\n    }\n    const samples_per_record = record_channel_map[this.channels.length];\n    let samples_in_blob = null;\n    try {\n      samples_in_blob = this.check_blob_size(buffer);\n    } catch(err) {\n      samples_in_blob = (buffer.byteLength - this.num_header_bytes) / this.bytes_per_sample;\n    }\n    const blob = new Int16Array(buffer, this.num_header_bytes, samples_in_blob);\n    for (let c=0; c < this.num_channels; c++) {\n      this.channels[c].init(this.num_records, this.record_duration);\n    }\n    for (let r=0; r < this.num_records; r++) {\n      for (let c=0; c < this.num_channels; c++) {\n        this.channels[c].set_record(r,\n          blob.slice(\n            r * samples_per_record + record_channel_map[c],\n            r * samples_per_record + record_channel_map[c + 1]\n          )\n        );\n      }\n    }\n    this.sampling_rate = {};\n    for(let label in this.channel_by_label) {\n      const channel = this.channel_by_label[label];\n      this.sampling_rate[label] = channel.sampling_rate;\n    }\n  }\n\n  relative_time(milliseconds) {\n    return this.startdatetime.getTime() + milliseconds;\n  }\n\n}\n\nmodule.exports = EDF;\n\n\n//# sourceURL=webpack:///./node_modules/edfjs/src/edf.js?");

/***/ }),

/***/ "./node_modules/edfjs/src/index.js":
/*!*****************************************!*\
  !*** ./node_modules/edfjs/src/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\n\n\nconst EDF = __webpack_require__(/*! ./edf */ \"./node_modules/edfjs/src/edf.js\");\nconst utils = __webpack_require__(/*! ./utils */ \"./node_modules/edfjs/src/utils.js\");\nconst Channel = __webpack_require__(/*! ./channel */ \"./node_modules/edfjs/src/channel.js\");\n\nconst edfjs = {\n  EDF: EDF,\n  Channel: Channel,\n  string_from_buffer: utils.string_from_buffer\n};\n\nmodule.exports = edfjs;\nglobal.edfjs = edfjs;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/edfjs/src/index.js?");

/***/ }),

/***/ "./node_modules/edfjs/src/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/edfjs/src/utils.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\nfunction toString(c) {\n  return String(c).trim();\n}\n\nfunction string_from_buffer(buffer, start, end) {\n  const ba = new Uint8Array(buffer, start, end-start);\n  return String.fromCharCode.apply(null, ba);\n}\n\nfunction assert(condition, msg='') {\n  if (!condition) {\n    throw 'Assertion Error: ' + msg;\n  }\n}\n\nfunction parseDateTime(date, time, century) {\n  century = century || '20';\n  let year, month, day, hour, minute, second, milliseconds;\n  if (date.includes('-')) {\n    date = date.split('-');\n    year = date[0];\n    month = date[1];\n    day = date[2];\n  } else if (date.includes('/')) {\n    date = date.split('/');\n    year = date[2];\n    month = date[0];\n    day = date[1];\n  } else if (date.includes('.')) {\n    date = date.split('.');\n    year = date[2];\n    month = date[1];\n    day = date[0];\n  }\n  month = month - 1;\n  if (year.length == 2) {\n    year = century + year;\n  }\n  time = time.replace(/\\./g, ':').split(':');\n  hour = time[0];\n  minute = time[1];\n  second = time[2];\n  milliseconds = time[3];\n  if (milliseconds && milliseconds.length != 3) {\n    for (let i=0; i < 3 - milliseconds.length; i++) {\n      milliseconds += '0';\n    }\n    milliseconds = milliseconds.substring(0, 4);\n  }\n  return new Date(Date.UTC(year, month, day, hour, minute, second, milliseconds || 0));\n}\n\nmodule.exports = {\n  toString: toString,\n  string_from_buffer: string_from_buffer,\n  assert: assert,\n  parseDateTime: parseDateTime\n};\n\n\n//# sourceURL=webpack:///./node_modules/edfjs/src/utils.js?");

/***/ }),

/***/ "./node_modules/papaparse/papaparse.min.js":
/*!*************************************************!*\
  !*** ./node_modules/papaparse/papaparse.min.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* @license\nPapa Parse\nv5.2.0\nhttps://github.com/mholt/PapaParse\nLicense: MIT\n*/\n!function(e,t){ true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (t),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):undefined}(this,function s(){\"use strict\";var f=\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:void 0!==f?f:{};var n=!f.document&&!!f.postMessage,o=n&&/blob:/i.test((f.location||{}).protocol),a={},h=0,b={parse:function(e,t){var i=(t=t||{}).dynamicTyping||!1;U(i)&&(t.dynamicTypingFunction=i,i={});if(t.dynamicTyping=i,t.transform=!!U(t.transform)&&t.transform,t.worker&&b.WORKERS_SUPPORTED){var r=function(){if(!b.WORKERS_SUPPORTED)return!1;var e=(i=f.URL||f.webkitURL||null,r=s.toString(),b.BLOB_URL||(b.BLOB_URL=i.createObjectURL(new Blob([\"(\",r,\")();\"],{type:\"text/javascript\"})))),t=new f.Worker(e);var i,r;return t.onmessage=_,t.id=h++,a[t.id]=t}();return r.userStep=t.step,r.userChunk=t.chunk,r.userComplete=t.complete,r.userError=t.error,t.step=U(t.step),t.chunk=U(t.chunk),t.complete=U(t.complete),t.error=U(t.error),delete t.worker,void r.postMessage({input:e,config:t,workerId:r.id})}var n=null;b.NODE_STREAM_INPUT,\"string\"==typeof e?n=t.download?new l(t):new p(t):!0===e.readable&&U(e.read)&&U(e.on)?n=new g(t):(f.File&&e instanceof File||e instanceof Object)&&(n=new c(t));return n.stream(e)},unparse:function(e,t){var n=!1,_=!0,m=\",\",v=\"\\r\\n\",s='\"',a=s+s,i=!1,r=null;!function(){if(\"object\"!=typeof t)return;\"string\"!=typeof t.delimiter||b.BAD_DELIMITERS.filter(function(e){return-1!==t.delimiter.indexOf(e)}).length||(m=t.delimiter);(\"boolean\"==typeof t.quotes||\"function\"==typeof t.quotes||Array.isArray(t.quotes))&&(n=t.quotes);\"boolean\"!=typeof t.skipEmptyLines&&\"string\"!=typeof t.skipEmptyLines||(i=t.skipEmptyLines);\"string\"==typeof t.newline&&(v=t.newline);\"string\"==typeof t.quoteChar&&(s=t.quoteChar);\"boolean\"==typeof t.header&&(_=t.header);if(Array.isArray(t.columns)){if(0===t.columns.length)throw new Error(\"Option columns is empty\");r=t.columns}void 0!==t.escapeChar&&(a=t.escapeChar+s)}();var o=new RegExp(q(s),\"g\");\"string\"==typeof e&&(e=JSON.parse(e));if(Array.isArray(e)){if(!e.length||Array.isArray(e[0]))return u(null,e,i);if(\"object\"==typeof e[0])return u(r||h(e[0]),e,i)}else if(\"object\"==typeof e)return\"string\"==typeof e.data&&(e.data=JSON.parse(e.data)),Array.isArray(e.data)&&(e.fields||(e.fields=e.meta&&e.meta.fields),e.fields||(e.fields=Array.isArray(e.data[0])?e.fields:h(e.data[0])),Array.isArray(e.data[0])||\"object\"==typeof e.data[0]||(e.data=[e.data])),u(e.fields||[],e.data||[],i);throw new Error(\"Unable to serialize unrecognized input\");function h(e){if(\"object\"!=typeof e)return[];var t=[];for(var i in e)t.push(i);return t}function u(e,t,i){var r=\"\";\"string\"==typeof e&&(e=JSON.parse(e)),\"string\"==typeof t&&(t=JSON.parse(t));var n=Array.isArray(e)&&0<e.length,s=!Array.isArray(t[0]);if(n&&_){for(var a=0;a<e.length;a++)0<a&&(r+=m),r+=y(e[a],a);0<t.length&&(r+=v)}for(var o=0;o<t.length;o++){var h=n?e.length:t[o].length,u=!1,f=n?0===Object.keys(t[o]).length:0===t[o].length;if(i&&!n&&(u=\"greedy\"===i?\"\"===t[o].join(\"\").trim():1===t[o].length&&0===t[o][0].length),\"greedy\"===i&&n){for(var d=[],l=0;l<h;l++){var c=s?e[l]:l;d.push(t[o][c])}u=\"\"===d.join(\"\").trim()}if(!u){for(var p=0;p<h;p++){0<p&&!f&&(r+=m);var g=n&&s?e[p]:p;r+=y(t[o][g],p)}o<t.length-1&&(!i||0<h&&!f)&&(r+=v)}}return r}function y(e,t){if(null==e)return\"\";if(e.constructor===Date)return JSON.stringify(e).slice(1,25);var i=e.toString().replace(o,a),r=\"boolean\"==typeof n&&n||\"function\"==typeof n&&n(e,t)||Array.isArray(n)&&n[t]||function(e,t){for(var i=0;i<t.length;i++)if(-1<e.indexOf(t[i]))return!0;return!1}(i,b.BAD_DELIMITERS)||-1<i.indexOf(m)||\" \"===i.charAt(0)||\" \"===i.charAt(i.length-1);return r?s+i+s:i}}};if(b.RECORD_SEP=String.fromCharCode(30),b.UNIT_SEP=String.fromCharCode(31),b.BYTE_ORDER_MARK=\"\\ufeff\",b.BAD_DELIMITERS=[\"\\r\",\"\\n\",'\"',b.BYTE_ORDER_MARK],b.WORKERS_SUPPORTED=!n&&!!f.Worker,b.NODE_STREAM_INPUT=1,b.LocalChunkSize=10485760,b.RemoteChunkSize=5242880,b.DefaultDelimiter=\",\",b.Parser=w,b.ParserHandle=i,b.NetworkStreamer=l,b.FileStreamer=c,b.StringStreamer=p,b.ReadableStreamStreamer=g,f.jQuery){var d=f.jQuery;d.fn.parse=function(o){var i=o.config||{},h=[];return this.each(function(e){if(!(\"INPUT\"===d(this).prop(\"tagName\").toUpperCase()&&\"file\"===d(this).attr(\"type\").toLowerCase()&&f.FileReader)||!this.files||0===this.files.length)return!0;for(var t=0;t<this.files.length;t++)h.push({file:this.files[t],inputElem:this,instanceConfig:d.extend({},i)})}),e(),this;function e(){if(0!==h.length){var e,t,i,r,n=h[0];if(U(o.before)){var s=o.before(n.file,n.inputElem);if(\"object\"==typeof s){if(\"abort\"===s.action)return e=\"AbortError\",t=n.file,i=n.inputElem,r=s.reason,void(U(o.error)&&o.error({name:e},t,i,r));if(\"skip\"===s.action)return void u();\"object\"==typeof s.config&&(n.instanceConfig=d.extend(n.instanceConfig,s.config))}else if(\"skip\"===s)return void u()}var a=n.instanceConfig.complete;n.instanceConfig.complete=function(e){U(a)&&a(e,n.file,n.inputElem),u()},b.parse(n.file,n.instanceConfig)}else U(o.complete)&&o.complete()}function u(){h.splice(0,1),e()}}}function u(e){this._handle=null,this._finished=!1,this._completed=!1,this._halted=!1,this._input=null,this._baseIndex=0,this._partialLine=\"\",this._rowCount=0,this._start=0,this._nextChunk=null,this.isFirstChunk=!0,this._completeResults={data:[],errors:[],meta:{}},function(e){var t=E(e);t.chunkSize=parseInt(t.chunkSize),e.step||e.chunk||(t.chunkSize=null);this._handle=new i(t),(this._handle.streamer=this)._config=t}.call(this,e),this.parseChunk=function(e,t){if(this.isFirstChunk&&U(this._config.beforeFirstChunk)){var i=this._config.beforeFirstChunk(e);void 0!==i&&(e=i)}this.isFirstChunk=!1,this._halted=!1;var r=this._partialLine+e;this._partialLine=\"\";var n=this._handle.parse(r,this._baseIndex,!this._finished);if(!this._handle.paused()&&!this._handle.aborted()){var s=n.meta.cursor;this._finished||(this._partialLine=r.substring(s-this._baseIndex),this._baseIndex=s),n&&n.data&&(this._rowCount+=n.data.length);var a=this._finished||this._config.preview&&this._rowCount>=this._config.preview;if(o)f.postMessage({results:n,workerId:b.WORKER_ID,finished:a});else if(U(this._config.chunk)&&!t){if(this._config.chunk(n,this._handle),this._handle.paused()||this._handle.aborted())return void(this._halted=!0);n=void 0,this._completeResults=void 0}return this._config.step||this._config.chunk||(this._completeResults.data=this._completeResults.data.concat(n.data),this._completeResults.errors=this._completeResults.errors.concat(n.errors),this._completeResults.meta=n.meta),this._completed||!a||!U(this._config.complete)||n&&n.meta.aborted||(this._config.complete(this._completeResults,this._input),this._completed=!0),a||n&&n.meta.paused||this._nextChunk(),n}this._halted=!0},this._sendError=function(e){U(this._config.error)?this._config.error(e):o&&this._config.error&&f.postMessage({workerId:b.WORKER_ID,error:e,finished:!1})}}function l(e){var r;(e=e||{}).chunkSize||(e.chunkSize=b.RemoteChunkSize),u.call(this,e),this._nextChunk=n?function(){this._readChunk(),this._chunkLoaded()}:function(){this._readChunk()},this.stream=function(e){this._input=e,this._nextChunk()},this._readChunk=function(){if(this._finished)this._chunkLoaded();else{if(r=new XMLHttpRequest,this._config.withCredentials&&(r.withCredentials=this._config.withCredentials),n||(r.onload=y(this._chunkLoaded,this),r.onerror=y(this._chunkError,this)),r.open(this._config.downloadRequestBody?\"POST\":\"GET\",this._input,!n),this._config.downloadRequestHeaders){var e=this._config.downloadRequestHeaders;for(var t in e)r.setRequestHeader(t,e[t])}if(this._config.chunkSize){var i=this._start+this._config.chunkSize-1;r.setRequestHeader(\"Range\",\"bytes=\"+this._start+\"-\"+i)}try{r.send(this._config.downloadRequestBody)}catch(e){this._chunkError(e.message)}n&&0===r.status&&this._chunkError()}},this._chunkLoaded=function(){4===r.readyState&&(r.status<200||400<=r.status?this._chunkError():(this._start+=this._config.chunkSize?this._config.chunkSize:r.responseText.length,this._finished=!this._config.chunkSize||this._start>=function(e){var t=e.getResponseHeader(\"Content-Range\");if(null===t)return-1;return parseInt(t.substring(t.lastIndexOf(\"/\")+1))}(r),this.parseChunk(r.responseText)))},this._chunkError=function(e){var t=r.statusText||e;this._sendError(new Error(t))}}function c(e){var r,n;(e=e||{}).chunkSize||(e.chunkSize=b.LocalChunkSize),u.call(this,e);var s=\"undefined\"!=typeof FileReader;this.stream=function(e){this._input=e,n=e.slice||e.webkitSlice||e.mozSlice,s?((r=new FileReader).onload=y(this._chunkLoaded,this),r.onerror=y(this._chunkError,this)):r=new FileReaderSync,this._nextChunk()},this._nextChunk=function(){this._finished||this._config.preview&&!(this._rowCount<this._config.preview)||this._readChunk()},this._readChunk=function(){var e=this._input;if(this._config.chunkSize){var t=Math.min(this._start+this._config.chunkSize,this._input.size);e=n.call(e,this._start,t)}var i=r.readAsText(e,this._config.encoding);s||this._chunkLoaded({target:{result:i}})},this._chunkLoaded=function(e){this._start+=this._config.chunkSize,this._finished=!this._config.chunkSize||this._start>=this._input.size,this.parseChunk(e.target.result)},this._chunkError=function(){this._sendError(r.error)}}function p(e){var i;u.call(this,e=e||{}),this.stream=function(e){return i=e,this._nextChunk()},this._nextChunk=function(){if(!this._finished){var e,t=this._config.chunkSize;return t?(e=i.substring(0,t),i=i.substring(t)):(e=i,i=\"\"),this._finished=!i,this.parseChunk(e)}}}function g(e){u.call(this,e=e||{});var t=[],i=!0,r=!1;this.pause=function(){u.prototype.pause.apply(this,arguments),this._input.pause()},this.resume=function(){u.prototype.resume.apply(this,arguments),this._input.resume()},this.stream=function(e){this._input=e,this._input.on(\"data\",this._streamData),this._input.on(\"end\",this._streamEnd),this._input.on(\"error\",this._streamError)},this._checkIsFinished=function(){r&&1===t.length&&(this._finished=!0)},this._nextChunk=function(){this._checkIsFinished(),t.length?this.parseChunk(t.shift()):i=!0},this._streamData=y(function(e){try{t.push(\"string\"==typeof e?e:e.toString(this._config.encoding)),i&&(i=!1,this._checkIsFinished(),this.parseChunk(t.shift()))}catch(e){this._streamError(e)}},this),this._streamError=y(function(e){this._streamCleanUp(),this._sendError(e)},this),this._streamEnd=y(function(){this._streamCleanUp(),r=!0,this._streamData(\"\")},this),this._streamCleanUp=y(function(){this._input.removeListener(\"data\",this._streamData),this._input.removeListener(\"end\",this._streamEnd),this._input.removeListener(\"error\",this._streamError)},this)}function i(m){var a,o,h,r=Math.pow(2,53),n=-r,s=/^\\s*-?(\\d+\\.?|\\.\\d+|\\d+\\.\\d+)(e[-+]?\\d+)?\\s*$/,u=/(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))/,t=this,i=0,f=0,d=!1,e=!1,l=[],c={data:[],errors:[],meta:{}};if(U(m.step)){var p=m.step;m.step=function(e){if(c=e,_())g();else{if(g(),0===c.data.length)return;i+=e.data.length,m.preview&&i>m.preview?o.abort():(c.data=c.data[0],p(c,t))}}}function v(e){return\"greedy\"===m.skipEmptyLines?\"\"===e.join(\"\").trim():1===e.length&&0===e[0].length}function g(){if(c&&h&&(k(\"Delimiter\",\"UndetectableDelimiter\",\"Unable to auto-detect delimiting character; defaulted to '\"+b.DefaultDelimiter+\"'\"),h=!1),m.skipEmptyLines)for(var e=0;e<c.data.length;e++)v(c.data[e])&&c.data.splice(e--,1);return _()&&function(){if(!c)return;function e(e){U(m.transformHeader)&&(e=m.transformHeader(e)),l.push(e)}if(Array.isArray(c.data[0])){for(var t=0;_()&&t<c.data.length;t++)c.data[t].forEach(e);c.data.splice(0,1)}else c.data.forEach(e)}(),function(){if(!c||!m.header&&!m.dynamicTyping&&!m.transform)return c;function e(e,t){var i,r=m.header?{}:[];for(i=0;i<e.length;i++){var n=i,s=e[i];m.header&&(n=i>=l.length?\"__parsed_extra\":l[i]),m.transform&&(s=m.transform(s,n)),s=y(n,s),\"__parsed_extra\"===n?(r[n]=r[n]||[],r[n].push(s)):r[n]=s}return m.header&&(i>l.length?k(\"FieldMismatch\",\"TooManyFields\",\"Too many fields: expected \"+l.length+\" fields but parsed \"+i,f+t):i<l.length&&k(\"FieldMismatch\",\"TooFewFields\",\"Too few fields: expected \"+l.length+\" fields but parsed \"+i,f+t)),r}var t=1;!c.data.length||Array.isArray(c.data[0])?(c.data=c.data.map(e),t=c.data.length):c.data=e(c.data,0);m.header&&c.meta&&(c.meta.fields=l);return f+=t,c}()}function _(){return m.header&&0===l.length}function y(e,t){return i=e,m.dynamicTypingFunction&&void 0===m.dynamicTyping[i]&&(m.dynamicTyping[i]=m.dynamicTypingFunction(i)),!0===(m.dynamicTyping[i]||m.dynamicTyping)?\"true\"===t||\"TRUE\"===t||\"false\"!==t&&\"FALSE\"!==t&&(function(e){if(s.test(e)){var t=parseFloat(e);if(n<t&&t<r)return!0}return!1}(t)?parseFloat(t):u.test(t)?new Date(t):\"\"===t?null:t):t;var i}function k(e,t,i,r){var n={type:e,code:t,message:i};void 0!==r&&(n.row=r),c.errors.push(n)}this.parse=function(e,t,i){var r=m.quoteChar||'\"';if(m.newline||(m.newline=function(e,t){e=e.substring(0,1048576);var i=new RegExp(q(t)+\"([^]*?)\"+q(t),\"gm\"),r=(e=e.replace(i,\"\")).split(\"\\r\"),n=e.split(\"\\n\"),s=1<n.length&&n[0].length<r[0].length;if(1===r.length||s)return\"\\n\";for(var a=0,o=0;o<r.length;o++)\"\\n\"===r[o][0]&&a++;return a>=r.length/2?\"\\r\\n\":\"\\r\"}(e,r)),h=!1,m.delimiter)U(m.delimiter)&&(m.delimiter=m.delimiter(e),c.meta.delimiter=m.delimiter);else{var n=function(e,t,i,r,n){var s,a,o,h;n=n||[\",\",\"\\t\",\"|\",\";\",b.RECORD_SEP,b.UNIT_SEP];for(var u=0;u<n.length;u++){var f=n[u],d=0,l=0,c=0;o=void 0;for(var p=new w({comments:r,delimiter:f,newline:t,preview:10}).parse(e),g=0;g<p.data.length;g++)if(i&&v(p.data[g]))c++;else{var _=p.data[g].length;l+=_,void 0!==o?0<_&&(d+=Math.abs(_-o),o=_):o=_}0<p.data.length&&(l/=p.data.length-c),(void 0===a||d<=a)&&(void 0===h||h<l)&&1.99<l&&(a=d,s=f,h=l)}return{successful:!!(m.delimiter=s),bestDelimiter:s}}(e,m.newline,m.skipEmptyLines,m.comments,m.delimitersToGuess);n.successful?m.delimiter=n.bestDelimiter:(h=!0,m.delimiter=b.DefaultDelimiter),c.meta.delimiter=m.delimiter}var s=E(m);return m.preview&&m.header&&s.preview++,a=e,o=new w(s),c=o.parse(a,t,i),g(),d?{meta:{paused:!0}}:c||{meta:{paused:!1}}},this.paused=function(){return d},this.pause=function(){d=!0,o.abort(),a=U(m.chunk)?\"\":a.substring(o.getCharIndex())},this.resume=function(){t.streamer._halted?(d=!1,t.streamer.parseChunk(a,!0)):setTimeout(t.resume,3)},this.aborted=function(){return e},this.abort=function(){e=!0,o.abort(),c.meta.aborted=!0,U(m.complete)&&m.complete(c),a=\"\"}}function q(e){return e.replace(/[.*+?^${}()|[\\]\\\\]/g,\"\\\\$&\")}function w(e){var O,D=(e=e||{}).delimiter,I=e.newline,T=e.comments,A=e.step,L=e.preview,F=e.fastMode,z=O=void 0===e.quoteChar?'\"':e.quoteChar;if(void 0!==e.escapeChar&&(z=e.escapeChar),(\"string\"!=typeof D||-1<b.BAD_DELIMITERS.indexOf(D))&&(D=\",\"),T===D)throw new Error(\"Comment character same as delimiter\");!0===T?T=\"#\":(\"string\"!=typeof T||-1<b.BAD_DELIMITERS.indexOf(T))&&(T=!1),\"\\n\"!==I&&\"\\r\"!==I&&\"\\r\\n\"!==I&&(I=\"\\n\");var M=0,j=!1;this.parse=function(a,t,i){if(\"string\"!=typeof a)throw new Error(\"Input must be a string\");var r=a.length,e=D.length,n=I.length,s=T.length,o=U(A),h=[],u=[],f=[],d=M=0;if(!a)return R();if(F||!1!==F&&-1===a.indexOf(O)){for(var l=a.split(I),c=0;c<l.length;c++){if(f=l[c],M+=f.length,c!==l.length-1)M+=I.length;else if(i)return R();if(!T||f.substring(0,s)!==T){if(o){if(h=[],b(f.split(D)),S(),j)return R()}else b(f.split(D));if(L&&L<=c)return h=h.slice(0,L),R(!0)}}return R()}for(var p=a.indexOf(D,M),g=a.indexOf(I,M),_=new RegExp(q(z)+q(O),\"g\"),m=a.indexOf(O,M);;)if(a[M]!==O)if(T&&0===f.length&&a.substring(M,M+s)===T){if(-1===g)return R();M=g+n,g=a.indexOf(I,M),p=a.indexOf(D,M)}else{if(-1!==p&&(p<g||-1===g)){if(!(p<m)){f.push(a.substring(M,p)),M=p+e,p=a.indexOf(D,M);continue}var v=x(p,m,g);if(v&&void 0!==v.nextDelim){p=v.nextDelim,m=v.quoteSearch,f.push(a.substring(M,p)),M=p+e,p=a.indexOf(D,M);continue}}if(-1===g)break;if(f.push(a.substring(M,g)),C(g+n),o&&(S(),j))return R();if(L&&h.length>=L)return R(!0)}else for(m=M,M++;;){if(-1===(m=a.indexOf(O,m+1)))return i||u.push({type:\"Quotes\",code:\"MissingQuotes\",message:\"Quoted field unterminated\",row:h.length,index:M}),E();if(m===r-1)return E(a.substring(M,m).replace(_,O));if(O!==z||a[m+1]!==z){if(O===z||0===m||a[m-1]!==z){-1!==p&&p<m+1&&(p=a.indexOf(D,m+1)),-1!==g&&g<m+1&&(g=a.indexOf(I,m+1));var y=w(-1===g?p:Math.min(p,g));if(a[m+1+y]===D){f.push(a.substring(M,m).replace(_,O)),a[M=m+1+y+e]!==O&&(m=a.indexOf(O,M)),p=a.indexOf(D,M),g=a.indexOf(I,M);break}var k=w(g);if(a.substring(m+1+k,m+1+k+n)===I){if(f.push(a.substring(M,m).replace(_,O)),C(m+1+k+n),p=a.indexOf(D,M),m=a.indexOf(O,M),o&&(S(),j))return R();if(L&&h.length>=L)return R(!0);break}u.push({type:\"Quotes\",code:\"InvalidQuotes\",message:\"Trailing quote on quoted field is malformed\",row:h.length,index:M}),m++}}else m++}return E();function b(e){h.push(e),d=M}function w(e){var t=0;if(-1!==e){var i=a.substring(m+1,e);i&&\"\"===i.trim()&&(t=i.length)}return t}function E(e){return i||(void 0===e&&(e=a.substring(M)),f.push(e),M=r,b(f),o&&S()),R()}function C(e){M=e,b(f),f=[],g=a.indexOf(I,M)}function R(e){return{data:h,errors:u,meta:{delimiter:D,linebreak:I,aborted:j,truncated:!!e,cursor:d+(t||0)}}}function S(){A(R()),h=[],u=[]}function x(e,t,i){var r={nextDelim:void 0,quoteSearch:void 0},n=a.indexOf(O,t+1);if(t<e&&e<n&&(n<i||-1===i)){var s=a.indexOf(D,n);if(-1===s)return r;n<s&&(n=a.indexOf(O,n+1)),r=x(s,n,i)}else r={nextDelim:e,quoteSearch:t};return r}},this.abort=function(){j=!0},this.getCharIndex=function(){return M}}function _(e){var t=e.data,i=a[t.workerId],r=!1;if(t.error)i.userError(t.error,t.file);else if(t.results&&t.results.data){var n={abort:function(){r=!0,m(t.workerId,{data:[],errors:[],meta:{aborted:!0}})},pause:v,resume:v};if(U(i.userStep)){for(var s=0;s<t.results.data.length&&(i.userStep({data:t.results.data[s],errors:t.results.errors,meta:t.results.meta},n),!r);s++);delete t.results}else U(i.userChunk)&&(i.userChunk(t.results,n,t.file),delete t.results)}t.finished&&!r&&m(t.workerId,t.results)}function m(e,t){var i=a[e];U(i.userComplete)&&i.userComplete(t),i.terminate(),delete a[e]}function v(){throw new Error(\"Not implemented.\")}function E(e){if(\"object\"!=typeof e||null===e)return e;var t=Array.isArray(e)?[]:{};for(var i in e)t[i]=E(e[i]);return t}function y(e,t){return function(){e.apply(t,arguments)}}function U(e){return\"function\"==typeof e}return o&&(f.onmessage=function(e){var t=e.data;void 0===b.WORKER_ID&&t&&(b.WORKER_ID=t.workerId);if(\"string\"==typeof t.input)f.postMessage({workerId:b.WORKER_ID,results:b.parse(t.input,t.config),finished:!0});else if(f.File&&t.input instanceof File||t.input instanceof Object){var i=b.parse(t.input,t.config);i&&f.postMessage({workerId:b.WORKER_ID,results:i,finished:!0})}}),(l.prototype=Object.create(u.prototype)).constructor=l,(c.prototype=Object.create(u.prototype)).constructor=c,(p.prototype=Object.create(p.prototype)).constructor=p,(g.prototype=Object.create(u.prototype)).constructor=g,b});\n\n//# sourceURL=webpack:///./node_modules/papaparse/papaparse.min.js?");

/***/ }),

/***/ "./node_modules/path-browserify/index.js":
/*!***********************************************!*\
  !*** ./node_modules/path-browserify/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,\n// backported and transplited with Babel, with backwards-compat fixes\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function (path) {\n  if (typeof path !== 'string') path = path + '';\n  if (path.length === 0) return '.';\n  var code = path.charCodeAt(0);\n  var hasRoot = code === 47 /*/*/;\n  var end = -1;\n  var matchedSlash = true;\n  for (var i = path.length - 1; i >= 1; --i) {\n    code = path.charCodeAt(i);\n    if (code === 47 /*/*/) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n      // We saw the first non-path separator\n      matchedSlash = false;\n    }\n  }\n\n  if (end === -1) return hasRoot ? '/' : '.';\n  if (hasRoot && end === 1) {\n    // return '//';\n    // Backwards-compat fix:\n    return '/';\n  }\n  return path.slice(0, end);\n};\n\nfunction basename(path) {\n  if (typeof path !== 'string') path = path + '';\n\n  var start = 0;\n  var end = -1;\n  var matchedSlash = true;\n  var i;\n\n  for (i = path.length - 1; i >= 0; --i) {\n    if (path.charCodeAt(i) === 47 /*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // path component\n      matchedSlash = false;\n      end = i + 1;\n    }\n  }\n\n  if (end === -1) return '';\n  return path.slice(start, end);\n}\n\n// Uses a mixed approach for backwards-compatibility, as ext behavior changed\n// in new Node.js versions, so only basename() above is backported here\nexports.basename = function (path, ext) {\n  var f = basename(path);\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\nexports.extname = function (path) {\n  if (typeof path !== 'string') path = path + '';\n  var startDot = -1;\n  var startPart = 0;\n  var end = -1;\n  var matchedSlash = true;\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find\n  var preDotState = 0;\n  for (var i = path.length - 1; i >= 0; --i) {\n    var code = path.charCodeAt(i);\n    if (code === 47 /*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n    if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension\n      matchedSlash = false;\n      end = i + 1;\n    }\n    if (code === 46 /*.*/) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n    } else if (startDot !== -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension\n      preDotState = -1;\n    }\n  }\n\n  if (startDot === -1 || end === -1 ||\n      // We saw a non-dot character immediately before the dot\n      preDotState === 0 ||\n      // The (right-most) trimmed path component is exactly '..'\n      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n    return '';\n  }\n  return path.slice(startDot, end);\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/path-browserify/index.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./web/index.js":
/*!**********************!*\
  !*** ./web/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n__webpack_require__(/*! menubar */ \"./code/menubar.js\");\n__webpack_require__(/*! signal_view */ \"./code/signal_view.js\");\n__webpack_require__(/*! filtered_edf */ \"./code/filtered_edf.js\");\n__webpack_require__(/*! hypnogram_elem */ \"./code/hypnogram_elem.js\");\n__webpack_require__(/*! signal_source_elem */ \"./code/signal_source_elem.js\");\n__webpack_require__(/*! annotation_list_elem */ \"./code/annotation_list_elem.js\");\n__webpack_require__(/*! classify_elem */ \"./code/classify_elem.js\");\nconst Keyboard = __webpack_require__(/*! keyboard */ \"./code/keyboard.js\").Keyboard;\n\nlet globalKeyboard = new Keyboard();\n\n\n//# sourceURL=webpack:///./web/index.js?");

/***/ })

/******/ });